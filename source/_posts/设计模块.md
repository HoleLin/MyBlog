---
title: 设计模块
date: 2021-05-30 17:54:15
tags:
- 设计模式
categories:
- 设计模式
---

#### 参考文献

* [Java设计模式精讲 Debug方式+内存分析](https://coding.imooc.com/class/270.html)

#### 前置知识

##### UML 

> UML (Unified Modeling Language) 统一建模语言

* 特点
  * UML是一种开放的方法;
  * 用于说明,可视化,构建和编写一个正在开发的面向对象的软件密级系统的制品的开放方法;
* UML2.2分类: 一共14中图示
  * 结构式图形: 强调的是系统式的建模;
    * 静态图
      * 类图
      * 对象图
      * 包图
    * 实现图
      * 组件图
      * 部署图
    * 剖面图
    * 复合结构图
  * 行为式图形: 强调系统模型中触发的事件;
    * 活动图
    * 状态图
    * 用例图
  * 交互式图形: 属于行为式图形子集合,强调系统模型中资料流程.
    * 通信图
    * 时序图
    * 交互概述图
    * 时间图

##### 类图

> Class Diagram: 用于表示类,接口,实例等之间相互间的静态关系
> * UML箭头方向: **从子类指向父类**
>   * 定义子类是需要通过extends关键字指定父类
>   * 子类一定知道父类定义,但父类并不知道子类的定义
>   * 只有知道对方信息是才能指向对方
> * 实线: **继承(extends)** 虚线: **实现(implements)**
>   * 空心三角箭头: 继承或实现
>   * 实线--继承: `is a` 关系,扩展目的(不虚,很现实);
>   * 虚线--实现: 虚线代表"虚",无实体
> * 实现: **关联**  虚线: **依赖**
>   * 实现--关联: 关系稳定,实打实的关系
>     * 表示一个类对象和另一个类对象有关联
>     * 通常是一个类中有另一个类对象作为属性
>   * 虚线--依赖关系: 临时用一下,若即若离,虚无缥缈,若有若无;
>     * 表示一种使用关系,一个类需要借助另一个类来实现功能.
>     * 一般是一个类使用另一个类作为参数使用,或作为返回值;
> * 实心菱形:**组合**  空心菱形: **聚合** 
>   * 菱形就是一个盛对象的器皿
>   * 组合: 代表**满器皿**里,已经有实体结果存在,生死与共;
>     * 整体和局部的关系和聚合的关系相比,关系更加强烈,两者有着**相同的生命周期**,`contans-a`的关系;
>     * 强关系
>   * 聚合: 代表空器皿里面可以放很多**相同**的东西,聚在一起(箭头方向所指的类)
>     * 整体和局部的关系,**两者有着独立的生命周期**,是`has a`的关系
>     * 弱关系
> * 常见数字表达以及含义
>   * 0..1: 0或1个实例
>   * 0..*: 0或多个实例
>   * 1..1: 1个实例
>   * 1: 只能一个实例
>   * 1..*: 至少一个实例
> * 斜体为抽象
> * +: public
> * -: private
> * #: protected
> * ~: default(包权限)
> * 下划线: static(静态)

> Program to an `interface`, not an `Impltemention`
>
> * 使用者不需要知道数据类型,结构,算法的细节;
> * 使用者不需要知道实现细节,只需要知道提供的接口;
> * 利用抽象,封装,动态绑定,多态,符合面对对象的特质和理论;
>
> Favor `object compostion` over `class inheritance`
>
> * 继承需要给子类暴露一些父类的设计和实现细节;
> * 父类实现的改变会造成子类也需要改变;
> * 我们以为继承主要是为了代码重用,但实际上在子类需要重新实现很多父类的方法;
> * 继承更多的应该是为了多态;

##### UML时序图

> Sequence Diagram: 是显示对象之间交互的图,这些对象是时间顺序排列的.时序图中包括的建模元素主要有:
>
> * 对象(Actor)
> * 生命线(Lifeline)
> * 控制焦点(Focus of control)
> * 消息(Message)

#### 七大设计原则

##### 开闭原则

> 定义: 一个软件实体如类,模块和函数应该**对外扩展开放,对内修改关闭**;
>
> * 用抽象构建框架,用实现扩展细节;
>
> 优点: 提高软件系统的可复用性以及可维护性;

##### 依赖倒置原则

> 定义: 高层模块不应该依赖低层模块,**二者都应该依赖抽象**;
>
> * 抽象不应该依赖细节,细节应该依赖抽象;
> * 针对接口编程,不要针对实现编程;
>
> 优点: 
>
> * 可能减少的耦合性,;
> * 提高系统稳定性;
> * 提高代码可读性和可维护性;
> * 可降低修改程序所造成的风险;

##### 单一责任原则

> 定义: 不要存在多余一个导致类变更的原因;
>
> * 一个类/接口/方法只负责一项职责
>
> 优点: 
>
> * 降低累的复杂度;
> * 提高类的可读性;
> * 提高系统的可维护性;
> * 降低变更引起的风险;

##### 接口隔离原则

> 定义: 用多个专门的接口,而不适用单一的总接口,客户端不应该依赖它不需要的接口;
>
> * 一个类对一个类的依赖应该建立在最小的接口上
> * 建立单一接口,不要建立庞大臃肿的接口
> * 尽量细化接口,接口中方法尽量少
>
> 优点: 
>
> * 符合高内聚低耦合的设计思想,从而使类具有很好的可读性,可扩展性,可维护性.

##### 迪米特原则(最少知道原则)

> 定义: 一个对象应该对其他对象保持最少的了解,又叫最少知道原则;
>
> * 尽量降低类与类之间的耦合
>
> 优点: 
>
> * 降低类之间的耦合
> * 强调只和朋友交流,不和陌生人交流
>   * 朋友: 出现在成员变量,方法的输入,输出参数中的类称为成员朋友类,而出现在方法体内部的类不属于朋友类

##### 里氏替换原则

> 定义: 如果对每个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都替换成o2时程序P的行为没有发生变化,那么类型T2类型是类型T1的子类型.
>
> 定义扩展: 一个软件实体如果使用一个适用一个父类的话,那一定适用于子类,所有引用父类的地方必须能透明的使用其子类的对象,子类对象能够替换父类对象,而程序的逻辑不变.
>
> 引申意义: 子类可以扩展父类的功能,但不能改变父类原有的功能
>
> * 含义1: 子类可以实现父类的抽象方法,但不能覆盖父类的非抽象方法;
> * 含义2: 子类可以增加自己特有的方法;
> * 含义3: 当子类的方法重载父类的方法时,方法的前置条件(即方法的输入/入参)要比父类的方法的输入参数更宽松(更大);
> * 含义4: 当子类的方法实现父类的方法时(重写/重载或实现抽象方法)方法的后置条件(即方法的输出/返回值)要比父类更严格或相等(相等或小于);
>
> 优点:
>
> * 约束继承泛滥,开闭原则的一种体现;
> * 加强程序的健壮性,同时变更时也可以做到非常好的兼容性,提高程序的维护性,扩展性.降低需求变更时引入的风险;

* 组合/聚合复用原则

> 定义: 尽量使用对象组合/聚合,而不是继承关系达到软件复用的目的.
>
> * 聚合 has-A 
>
> * 组合contains-A
> * 继承 is-A
>
> 优点: 可以使系统更加灵活,降低类与类之间的耦合度,一个类的变化,对其他造成的影响相对较少.

#### 创建型

* _简单工厂模式(不属于GOF23种设计模式)_

  > 定义: 由一个工厂对象决定创建出哪一种产品类的实例;
  >
  > 类型: 创建型 不属于GOF23中设计模式
  >
  > 适用场景:
  >
  > * 工厂类负责创建的对象比较少;
  > * 客户端(应用层)只知道传入工厂类的参数,对于如何创建对象(逻辑)不关心;
  >
  > 优点: 只需要传入一个正确的参数,就可以获取所需要的对象,而无须知道其创建细节.
  >
  > 缺点: 工厂类的责任相对过重,增加新的产品需要修改工厂类的判断逻辑,违背开闭原则.

* 工厂方法模式(产品等级)

* 抽象工厂模式(产品族)

* 建造者模式

* **单例模式**(饿汉式和懒汉式,线程安全和非线程安全,单例模式的破坏方式)

* 原型模式

#### 结构型

* 外观模式
* 装饰者模式
* 适配器模式
* 享元模式
* 组合模式
* 桥接模式
* 代理模式

#### 行为型

* 模板方法模式
* 迭代器模式
* 策略模式
* 解释器模式
* 观察者模式
* 备忘录模式
* 命令模式
* 中介者模式
* 责任链模式
* 访问者模式
* 状态模式