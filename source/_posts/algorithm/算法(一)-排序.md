---
title: 算法(一)-排序
date: 2021-06-27 22:33:33
index_img: /img/cover/Algorithm.jpg
cover: /img/cover/Algorithm.jpg
tags: 
- 排序
categories: 
- 算法
---
###  排序

#### 公共方法

```java
    /**
     * 数组长度校验
     *
     * @param arr 待校验的数组
     * @return 当数组为空或者数组长度小于2时, 不用排序, 直接返回
     */
    private static boolean checkArray(int[] arr) {
        // 当数组为空或者数组长度小于2时,不用排序
        return arr == null || arr.length < 2;
    }

	/**
     * 交换数据 -- 数组
     *
     * @param arr 数组
     * @param i   待交换的值
     * @param j   待交换的值
     */
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        // 使用异或运算实现交换操作
        // arr[i] = arr[i] ^ arr[j];
        // arr[j] = arr[i] ^ arr[j];
        // arr[i] = arr[i] ^ arr[j];
    }
```

#### 各个排序

| 排序方法 | 时间复杂度(平均)     | 时间复杂度(最坏)     | 时间复杂度(最好)     | 空间复杂度           | 稳定性 |
| -------- | -------------------- | -------------------- | -------------------- | -------------------- | ------ |
| 冒泡排序 | O(n<sup>2</sup>)     | O(n<sup>2</sup>)     | O(n)                 | O(1)                 | 稳定   |
| 插入排序 | O(n<sup>2</sup>)     | O(n<sup>2</sup>)     | O(n)                 | O(1)                 | 稳定   |
| 归并排序 | O(nlog<sub>2</sub>n) | O(nlog<sub>2</sub>n) | O(nlog<sub>2</sub>n) | O(n)                 | 稳定   |
|          |                      |                      |                      |                      |        |
| 选择排序 | O(n<sup>2</sup>)     | O(n<sup>2</sup>)     | O(n<sup>2</sup>)     | O(1)                 | 不稳定 |
| 快速排序 | O(nlog<sub>2</sub>n) | O(n<sup>2</sup>)     | O(nlog<sub>2</sub>n) | O(nlog<sub>2</sub>n) | 不稳定 |
| 堆排序   | O(nlog<sub>2</sub>n) | O(nlog<sub>2</sub>n) | O(nlog<sub>2</sub>n) | O(1)                 | 不稳定 |
| 希尔排序 | O(n<sup>1.3</sup>)   | O(n<sup>2</sup>)     | O(n)                 | O(1)                 | 不稳定 |
|          |                      |                      |                      |                      |        |
| 计数排序 | O(n+k)               | O(n+k)               | O(n+k)               | O(n+k)               | 稳定   |
| 桶排序   | O(n+k)               | O(n<sup>2</sup>)     | O(n)                 | O(n+k)               | 稳定   |
| 基数排序 | O(n*k)               | O(n*k)               | O(n*k)               | O(n+k)               | 稳定   |
|          |                      |                      |                      |                      |        |



####  冒泡排序

* **思想**

  > * 比较两个相邻的元素，将值大的元素交换到右边.
  > * 如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式.
  > * N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次

* **实现**

  ```java
      /**
       * 冒泡排序
       *
       * @param arr 待排数组
       */
      public static void bubbleSort(int[] arr) {
          if (checkArray(arr)) {
              return;
          }
          for (int i = arr.length - 1; i > 0; i--) {
              for (int j = 0; j < i; j++) {
                  // 比较相邻的元素
                  if (arr[j] > arr[j + 1]) {
                      swap(arr, j, j + 1);
                  }
              }
          }
      }
  
  // 稳定性
  // 示例(升序排序): 6(1),5,4,3,2,6(2)
  // 第一轮: 5,4,3,2,6(1),6(2)
  // 第二轮: 4,3,2,5,6(1),6(2)
  // 第三轮: 3,2,4,5,6(1),6(2)
  // 第四轮: 2,3,4,5,6(1),6(2)
  ```

#### 插入排序

* 思想

* 实现

  ```java
      /**
       * 插入排序
       *
       * @param arr 待排数组
       */
      public static void insertionSort(int[] arr) {
          if (checkArray(arr)) {
              return;
          }
          // 插入排序
          // i作为指针作用遍历整个数组
          for (int i = 1; i < arr.length; i++) {
              // 先比较arr[j] 与 arr[j+1]
              // 当满足arr[j] > arr[j + 1] 说明顺序不对，则进行交换 j向前移动一位 继续判断是否满足arr[j] > arr[j + 1]
              // 满足就进行交换 直至j<0或者不满足arr[j] > arr[j + 1]
              // 当不满足arr[j] > arr[j + 1] 说明顺序是对的，则直接判断下一个位置
              for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
                  swap(arr, j, j + 1);
              }
              // 或者写成这样
  //            for (int j = i; j > 0 && arr[j-1] > arr[j]; j--) {
  //                swap(arr, j, j - 1);
  //            }
  
          }
      }
      
      /**
       * 改进后的插入排序
       * -- 减少交换次数
       *
       * @param arr 待排数组
       */
      public static void insertionSort2(int[] arr) {
          if (checkArray(arr)) {
              return;
          }
          for (int i = 1; i < arr.length; i++) {
              // 寻找元素arr[i]合适的插入位置
              int e = arr[i];
              // j保存元素e应该插入的位置
              int j;
              for (j = i; j > 0 && arr[j - 1] > e; j--) {
                  // 前一位数向后移动一位
                  arr[j] = arr[j - 1];
              }
              arr[j] = e;
          }
      }
  ```

  

####  选择排序

* **思想**

  > * 第一趟从n个元素的数据序列中选出关键字最小/大的元素并放在最前/后位置，下一趟从n-1个元素中选出最小/大的元素并放在最前/后位置。以此类推，经过n-1趟完成排序。

* **实现**

  ```java
      /**
       * 选择排序
       * -- 擂台法
       *
       * @param arr 待排序的数组
       */
      public static void selectionSort(int[] arr) {
          if (checkArray(arr)) {
              return;
          }
          int k;
          int j;
          for (int i = 0; i < arr.length - 1; i++) {
              // 设置擂主 k
              k = i;
              for (j = i + 1; j < arr.length; j++) {
                  if (arr[k] > arr[j]) {
                      k = j;
                  }
              }
              // 当擂主改变进行交换 减少交换次数
              if (k != i) {
                  swap(arr, k, i);
              }
          }
      }
  // 示例(升序排序): 6(1),5,4,3,6(2),2
  // 第一轮: 2,5,4,3,6(2),6(1)
  // 第二轮: 2,3,4,5,6(2),6(1)
  // 第三轮: 2,3,4,5,6(2),6(1)
  // 第四轮: 2,5,4,3,6(2),6(1)
  // 第五轮: 2,5,4,3,6(2),6(1)
  ```

#### 归并排序

#### 堆排序

#### 希尔排序

#### 桶排序





