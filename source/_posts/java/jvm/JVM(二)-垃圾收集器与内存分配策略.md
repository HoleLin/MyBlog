---
title: JVM-垃圾收集器与内存分配策略
date: 2022-01-02 14:43:16
index_img: /img/cover/Java.jpg
cover: /img/cover/Java.jpg
tags:
- 垃圾收集器
- 内存分配策略
- JVM
categories:
- Java
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 参考文献

* 深入理解Java虚拟机:JVM高级特性与最佳实践(第3版)

### 垃圾回收

* 哪些内存需要回收?
* 什么时候回收?
* 如何回收?

#### 判断对象已死的算法

##### 引用计数算法

* 在对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加一;当引用失效时,计数器就减一;任何时刻计数器为零的对象就是不可能在被使用.
* 优点: 
  * 虽然占用了额外的内存空间来计数,但是原理简单,判断效率也很高.
* 缺点:
  * 单纯的引用计数很难解决对象之间的互相循环引用的问题.

##### 可达性分析算法

* 基本思路:
  * 通过一系列称为"GC Roots"的跟对象作为起始节点集,从这些节点开始,根据引用关系向下搜索,搜索过程所走过的路径称为"引用链"(Reference Chain),如果某个对象GC Roots间没有任何引用链相连,或者用图论的话来说就是从GC Roots到这个对象不可达时,则证明此对象是不可能再被使用的.
* 在Java技术体系里面,固定可作为GC Roots的对象包括以下几种:
  * 在虚拟机(栈帧中的本地变量表)中引用的对象,比如各个现场被调用的方法堆栈中使用到的参数,局部变量,临时变量等;
  * 在方法区中类静态属性引用对象,比如Java类的引用类型静态变量;
  * 在方法区中常量引用的对象,比如字符串常量池(`String Table`)里面的引用;
  * 在本地方法栈中JNI(即通常说的Native方法)引用的对象;
  * Java虚拟机内部的引用,如基本数据类型对应的Class对象,一些常驻的异常对象(比如`NullPointException`,`OutOfMemoryError`)等,还有系统类加载器;
  * 所有被同步锁(`syschroized`关键字)持有的对象;
  * 反映Java虚拟机内部情况的JMXBean,JVMTI中注册的回调,本地代码缓存等;
  * 除了这些固定的GC Roots集合以外,根据用户所选用的垃圾收集器以及当前回收的内存区域不同,还可以有其他对象"临时性"地加入,共同构成完整的GC Roots集合.

#### 两次标记

* 即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们 暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：
  * 如果对象在进行可达性分析后发现没有与GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。假如对象没有覆盖`finalize()`方法，或者`finalize()`方法已经被虚拟机调用过，那么虚拟机将这两种 情况都视为“没有必要执行”。
* 如果这个对象被判定为确有必要执行`finalize()`方法，那么该对象将会被放置在一个名为 `F-Queue` 的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的`Finalizer `线程去执行它们的`finalize()` 方法。这里所说的“执行”是指虚拟机会触发这个方 法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的` finalize()`方法执行缓慢，或者更极端地发生了死循环，将很可能导致`F-Queue` 队列中的 其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。`finalize()`方法是对象逃 脱死亡命运的最后一次机会，稍后收集器将对`F-Queue` 中的对象进行第二次小规模的标记，如果对象要在  `finalize()`中成功拯救自己——只要重新与引用链上的任何一个对象建 立关联即可，譬如把自己（`this` 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它 
  就真的要被回收了。

### 引用

* 无论是通过引用计数算法判断对象的引用数量,还是通过可达性分析算法判断对象是否引用链可达,判断对象是否存活都和"引用"离不开关系.
* JDK1.2版本之后,Java对引用的概念进行了扩充,将引用分为强引用(Strongly Reference),软引用(Soft Reference),弱引用(Weak Reference)和虚引用(Phantom Reference),四种引用强度依次逐渐减弱.

#### 强引用

* 强引用是最传统的"引用"的定义,是指在程序代码中普遍存在的引用赋值,即类似`Object obj=new Object()`.无论任何情况下,只要强引用关系还存在,垃圾收集器就永远不会回收被引用的对象.

#### 软引用

* 用来描述一些还有用,但非必须的对象.只被软引用关联着的对象,在系统将要发生内存溢出异常前,会把这些对象列进回收范围之中进行第二次回收,如果这次回收还没有足够的内存,才会抛出内存溢出异常.在JDK1.2版本之后提供了`SoftReference`类来实现软引用.

#### 弱引用

* 用来描述那些非必须对象,但是它的强度比软引用更弱一些,被弱引用关联的对象只能生存到下一次垃圾收集发生为止.但垃圾收集器开始工作,无论当前内存是否足够,都会回收只被弱引用关联的对象.JDK1.2版本之后提供了`WeakReference`类来实现弱引用.

#### 虚引用

* 也被称为"幽灵引用"或者"幻影引用",它是最弱的一种引用关系.一个对象是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用来取得一个对象实例.设置一个对象虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知.在JDK1.2版本之后提供了`PhantomReference`类来实现虚引用.

### 方法区回收

* 方法区的垃圾收集主要回收两部分内容:废弃的常量和不再使用的类型.
* 判定一个类型是否属于“不再被使用 的类”的条件就比较苛刻了。需要同时满足下面三个条件：
  * 该类所有的实例都已经被回收，也就是  Java 堆中不存在该类及其任何派生子类的 实例。
  * 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如  OSGi、JSP 的重加载等，否则通常是很难达成的。
  * 该类对应的  java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
* Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允 许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收， HotSpot 虚拟机提供了`-Xnoclassgc` 参数进行控制，还可以使用`-verbose：class` 以及`-XX： 
  +TraceClass-Loading`、`-XX：+TraceClassUnLoading` 查看类加载和卸载信息，其中`-verbose：class` 和`-XX：+TraceClassLoading` 可以在  Product 版的虚拟机中使用，`-XX：+TraceClassUnLoading `参数需要FastDebug 版的虚拟机支持。
* 在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

### 垃圾收集算法

* 从如何判定对象消亡的角度出发,垃圾收集算法可以划分为"引用计数式收集"(Reference Counting GC)和"追踪式垃圾收集"(Tracing GC)两大类,这两类也经常被称为"直接垃圾收集"和"间接垃圾收集".
* 部分收集(Partial GC):指目标不是完整收集整个Java堆的垃圾收集,其中又分为:
  * 新生代收集(Minor GC/Young GC): 指目标只是新生代的垃圾收集.
  * 老年代收集(Major GC/Old GC): 指目标只是老年代的垃圾收集.目前只有CMS收集器会有单独收集老年代的行为.
  * 混合收集(Mixed GC): 指目标是收集整个新生代以及部分老年代的垃圾收集.目前只有G1收集器会有这种行为.
  * 整堆收集(Full GC): 收集整个Java堆和方法区的垃圾收集.


#### 分代收集理论

* 分代收集(Generational Collection)名为理论,实质上是一套符合大多数程序运行实际情况的经验法则,它建立在两个分代假说之上:
  * **弱分代假说(Weak Generational Hypothesis): 绝大多数对象都是朝生夕灭的.**
  * **强分代假说(Weak Generational Hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡.**
* 这两个分代假说共同奠定了很多常用的垃圾收集器的一致的设计原则:**收集器应该将Java堆划分出不同的区域,然后将回收对象依据年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同区域之中存储.**
  * 显而易见,通过一个区域中大多数对象都是朝生夕死,难以熬过垃圾收集过程,那么把它们集中放在一起,每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象,就能以较低的代价回收到大量的空间.
  * 如果剩下的都是难以消亡的对象,那把它们集中放在一块,虚拟机便可以使用较低的频率来回收这个区域,这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用.
* Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域.顾名思义,在新生代中,每次垃圾收集时都发现大批量两对象死去,而每次回收后存活的少量对象,将会逐步晋升到老年代中存放.**分代收集并非只是简单的划分一下内存区域那么容易,它至少存在一个明显的困难:对象不是孤立,对象之间存在跨代引用.**
  * 假如要现在进行一次只局限于新生代区域内的收集(Minor GC),但**新生代中的对象是完全有可能被老年代引用的**,为了找出该区域中的存货对象,不得不在固定的GC Roots之外,在额外遍历整个老年代中所有对象来确保可达性分析结果的正确性,反过来也是一样.这样无疑会给内存回收带来很大的性能负担.为了解决这个问题,就需要分代收集理论添加第三条经验法则
* **跨代引用假说(Intergenerational Reference Hypothesis): 跨代引用相对同代引用来说仅占极少数.**
  * 这其实是可根据前两条假说逻辑推理得出的隐含推论：**存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的**。举个例子，如果某个新生代对象存在跨代 引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。
  * 根据跨代引用假说,不应该再为了少量的跨代引用去扫描整个老年代,也不必浪费空间专门记录每一个对象是否存在哪些跨代引用,只需要在新生代上建立一个全局的数据结构(该结构被称为"记忆集",Remembered Set),这个结构把老年代划分成若干小块,标识出老年代的哪一块内存会存在跨代引用.

#### 标记-清除算法

* 最早出现也是最基础的垃圾收集算法是"标记-清除"(Mark-Sweep)算法.在1960年由有Lisp之父John McCarthy所提出.
* 算法分为"标记"和"清除"两个阶段:
  * 首先标记出所有需要回收的对象,在标记完成后,统一回收掉所有被标记的对象,也可以反过来,标记存活的对象,统一回收所有未被标记的对象.
  * 标记的过程就是对象是否属于垃圾的判定过程.
* 缺点:
  * 执行效率不稳定,如果Java堆中包含大量对象,而且其中大部分是需要被回收的,这时必须进行大量标记和清除的动作,导致标记和清除两个过程的执行效率都随对象数量增长而降低;
  * 内存空间的碎片化问题,标记,清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作.

#### 标记-复制算法

* 为了解决标记-清楚算法面对大量可回收对象时执行效率低的问题,1969年Fenichel提出了一种称为"**半区复制**"(Semispace Copying)的垃圾收集算法:
  * 它将可用内存按容量划分为大小相等的两块,每次只使用其中一块.当这一块的内存用完了,就将还存活着的对象复制到另外一块上面,然后再把已使用过的内存空间一次清理掉.如果内存中多数对象都是存活的,这种算法将会产生大量的内存间复制的开销,但对于多数对象都是可回收的情况,算法需要复制的就是占少数的存活对象,而且每次都是针对整个半区进行内存回收,分配内存时也就不用考虑有空间碎片的复杂情况,只需要移动堆顶指针,按顺序分配即可.
  * 代价:将可用的内存缩小为原来的一半,空间浪费太多了.研究表明新生代中的对象有98%熬不过第一轮收集。因此并不需要按照 1∶1 的比例来划分新生代的内存空间.
* 在 1989 年，Andrew Appel 针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel 式回收”.
  * Appel 式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的  Survivor 空间，每次分配内存只使用Eden 和其中一块  Survivor。发生垃圾搜集时，将  Eden 和  Survivor 中仍然存活的对象一次性复制到另外一块  Survivor 空间上，然后直接清理掉  Eden 和已用过的那块  Survivor空间。
  * HotSpot 虚拟机默认  Eden 和  Survivor 的大小比例是  **8∶1**，也即每次新生代中可用内存空间为整个新生代容量的  90%（Eden 的  80%加上一个  Survivor 的  10%），只有一个  Survivor 空间，即  10%的新生代是会被“浪费”的。当Survivor 空间不足以容纳一次  Minor GC 之后存活的对象时，就需要依赖其他内存区域 （实际上大多就是老年代）进行分配担保（Handle Promotion）。

#### 标记-整理算法

* 标记-复制算法在对象存活率较高时就是进行较多的复制操作,效率将会降低.更关键的是，如果不想浪费 50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100%存活的极端情况，所以在老年代一般不能直接选用这种算法。
* 针对老年代对象的存亡特征，1974 年 Edward Lueders 提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存.
* 标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法,而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策:
  * 进行移动存活对象操作,必须全程停止用户应用程序才行,即"Stop The World".
  * 不进行移动存活对象,则需要考虑离散的存活对象导致空间碎片化问题,从而只能依赖更为复杂的内存分配器和内存访问器来解决.(分区空闲分配链表),内存访问是用户程序最频繁的操作,这样影响应用程序的吞吐量.
  * HotSpot 虚拟机里面关注吞吐量的 Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的 CMS 收集器则是基于标记-清除算法的.

#### HotSpot 的算法细节实现

* 没看懂,需要重新阅读 2022年01月03日14:13:49

### 经典垃圾收集器

#### Serial收集器

* 单线程工作的收集器,说明它只会使用一个处理器或者一条收集线程去完成垃圾收集工作,更重要的是强调在它进行垃圾收集时,必须暂停其他所有工作线程,直到它收集结束.
* 优点:
  * 简单而高效(相对于其他收集器的单线程相对),对于内存资源受限的环境,它是所有收集器里面额外内存消耗(Memory Footprint)最小的;
  * 对于单核处理器或处理器核心数较少的环境来说,Serial收集器由于没有线程交互的开销,专心做垃圾收集自然可以获得最高的单线程收集效率.

#### ParNew收集器

* ParNew收集器实质上是**Serial收集器的多线程并行版本**,除了同时使用多线程进行垃圾收集之外,其余行为包括Serial收集器可用的所有控制参数(例如:`-XX: SurvivorRatio,-XX: PretenureSizeThreshold,-XX: HandlePromotionFailure`等),手机算法,Stop The World,对象分配规则,回收策略等都与Serial收集器完全一致.
* 运行在服务端模式下的HotSpot虚拟机,是JDK7之前的遗留系统中首选的新生代收集器.
* 除了Serial收集器外,目前只有它能与CMS收集器配合工作.

#### Parallel Scavenge收集器

* Parallel Scavenge 收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器.

* Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即：
  $$
  吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}
  $$

* Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的`-XX：MaxGCPauseMillis` 参数以及直接设置吞吐量大小的`-XX: GCTimeRatio` 参数.

  * `-XX：MaxGCPauseMillis `参数允许的值是一个大于 0 的毫秒数，收集器将尽力保证 内存回收花费的时间不超过用户设定值。不过大家不要异想天开地认为如果把这个参数 的值设置得更小一点就能使得系统的垃圾收集速度变得更快，垃圾收集停顿时间缩短是 以牺牲吞吐量和新生代空间为代价换取的:系统把新生代调得小一些，收集 300MB 新生代肯定比收集 500MB 快，但这也直接导致垃圾收集发生得更频繁，原来 10 秒收集一次、每次停顿 100 毫秒，现在变成 5 秒收集一次、每次停顿 70 毫秒。停顿时间的确在下降，但吞吐量也降下来了.
  * `-XX：GCTimeRatio` 参数的值则应当是一个大于  0 小于  100 的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为  19，那允许的最大垃圾收集时间就占总时间的  5%（即  1/(1+19)），默认值为  99，即允许最大  1%（即1/(1+99)）的垃圾收集时间。

* Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”.`-XX: +UseAdaptiveSizePolicy `虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）.

* 只需要把基本的内存数据设置好(如-Xmx 设置最大堆),然后使用`-XX：MaxGCPauseMillis` 参数（更关注最大停顿时间）或`-XX：GCTimeRatio`(更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是  Parallel Scavenge 收集器区别于  ParNew 收集器的一个重要特性。

#### Serial Old收集器

* Serial Old 是  Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的  HotSpot 虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在  JDK 5 以及之前的版本中与  Parallel Scavenge 收集器搭配使用，另外一种就是作为  CMS 收集器发生失败时的后备预案,在并发收集发生  Concurrent Mode Failure 时使用。

#### Paralled Old收集器

* Parallel Old 是  Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。这个收集器是直到  JDK 6 时才开始提供的，在此之前，新生代的Parallel Scavenge 收集器一直处于相当尴尬的状态，原因是如果新生代选择了  Parallel Scavenge 收集器，老年代除了  Serial Old（PS MarkSweep）收集器以外别无选择，其他表现良好的老年代收集器，如  CMS 无法与它配合工作。由于老年代  Serial Old 收集器在服务端应用性能上的“拖累”，使用  Parallel Scavenge 收集器也未必能在整体上获得吞吐量最大化的效果。同样，由于单线程的老年代收集中无法充分利用服务器多处理器的并行处理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的总吞吐量甚至不一定比  ParNew 加  CMS 的组合来得优秀。
* 直到  Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑  Parallel Scavenge 加  Parallel Old 收集器这个组合。

#### CMS收集器

* CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
* 运行步骤:
  * 初始标记(CMS initial mark)
  * 并发标记(CMS concurrent mark)
  * 重新标记(CMS remark)
  * 并发清除(CMS concurrent sweep)
* 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下  GC Roots 能直接关联到的对象，速度很快；并发标记阶段就是从  GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的.
* 由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的.
* 优点:并发收集,低停顿.

#### Garbage First收集器

* 开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式.
* G1 是一款主要面向服务端应用的垃圾收集器.
