---
title: JVM(六)-类加载
date: 2022-01-15 22:07:18
index_img: /img/cover/Java.jpg
cover: /img/cover/Java.jpg
tags:
- 类加载
categories:
- Java
- JVM
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 参考文献

* 深入理解Java虚拟机:JVM高级特性与最佳实践(第3版)

### 虚拟机类加载机制

* Java虚拟机把描述类的数据从Class文件加载到内存,并对数据进行校验,转换解析和初始化,最终形成可以被虚拟机直接使用的Java类型,这个过程被称作虚拟机的类加载机制.
* 在Java语言中,类型的加载,连接和初始化过程都是在程序运行期间完成的.

### 类加载的时机

* 一个类从被加载到虚拟机内存中开始,到卸载出内存为止,它的整个生命周期将经历**加载(Loading),验证(Verification),准备(Preparation),解析(Resolution),初始化(Initialization),使用(Using)**和**卸载(Unloading)**七个阶段.
  * 其中验证,准备,解析三个阶段被统称为**连接(Linking)**.

![img](https://www.holelin.cn/img/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png)

* **加载,验证,准备,初始化和卸载这个五个阶段的顺序是确定的**,类型的加载过程必须按照这种顺序按部就班的开始.解析阶段则不一定.
* 什么时候需要开始类加载过程的第一阶段"加载",<<Java虚拟机规范>>没有强制要求,但是对于初始化阶段,规范则是严格规定了有且只有六种必须立即对类进行"**初始化**"(而加载,验证,准备自然需要在此之前开始):
  * 遇到`new,getstatic,pustatic或invokestatic`这个四个字节码指令时,如果类型没有进行初始化,则需要先触发其初始化阶段.能够生成这四条场景的典型Java代码场景有:
    * 使用`new`关键字实例对象的时候;
    * 读取或设置一个类型的静态字段(被`final`修饰,已在编译器把结果放入常量池的静态字段除外[已经赋值,String和基础类型,不包括包装类型])的时候;
    * 调用一个类型的静态方法的时候.
  * 使用`java.lang.reflect`包的方法对类型进行反射调用的时候,如果类型没有进行过初始化,则需要先触发其初始化;
  * 当初始化类的时候,如果发现其父类还没有进行过初始化,则需要先触发其父类的初始化;
  * 当虚拟机启动时,用户需要指定一个要执行的主类(包含main()方法的那个类),虚拟机会先初始化这个类;
  * 当使用JDK7新加入的动态语言支持时,如果一个`java.lang.invoke.MethodHandle` 实例最后的解析结果为  REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
  * 当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始 
    化。
* 这六种场景的行为被称为对一个类型进行主动引用.除此之外,所有类型的方式都不会触发初始化,被称为被动引用.
* **接口的加载过程**与类加载过程稍微不同,接口与类真正有所区别的是六种场景中的第三种:
  * 当一个类在初始化时,要求其父类全部都已经初始化过了,但是一个接口在初始化时,并不要求其父类接口全部完成初始化,只有真正使用到父接口的时候(如引用接口中定义的变量)才会初始化.

### 类加载的过程

#### 加载

* 加载阶段是整个类加载(Class Loading)过程的一个阶段,在加载阶段,Java虚拟机需要完成以下三件事情:
  * 通过一个类的全限定名来获取定义此类的二进制字节流.
  * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构.
  * 在内存中生成一个代表这个类的`java.lang.Class`对象,作为方法区这个类的各种数据的访问入口.
* 加载阶段结束后,Java虚拟机外部的二进制字节流就按照虚拟机锁设定的格式存储在存储在方法区之中.类型数据妥善安置在方法区之后,会在Java堆内存中实例化一个`java.lang.Class`类的对象,这个对象将作为程序访问方法区中类型数据的外部接口.

#### 验证

* 验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合<<Java 虚拟机规范>>的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全.
* 从整体上看,验证阶段大致会完成下面四个阶段的校验动作:**文件格式验证**,**元数据验证**,**字节码验证**和**符号引用验证**.

##### 文件格式验证

* 第一阶段要验证字节流是否符合Class文件格式的规范,并且能被当前版本的虚拟机处理.这一阶段可能包括下面这些验证点:
  * 是否以魔数`0xCAFEBABE`开头;
  * 主次版本号是否在当前Java虚拟机接受范围之内;
  * 常量池的常量中是否有不被支持从常量类型(检查常量tag标志);
  * 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
  * CONSTANT_Utf8_info 型的常量中是否有不符合  UTF-8 编码的数据。 
  * Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息
  * ...
* 主要目的是保证输入的字节流能正确地解析并存储于方法区之内,格式上符合描述一个Java类型信息的要求.
* 这阶段的验证是基于二进 制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入 Java 虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。

##### 元数据验证

* 第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语 
  言规范》的要求，这个阶段可能包括的验证点如下：

  * 这个类是否有父类（除了  java.lang.Object 之外，所有的类都应当有父类）。

  * 这个类的父类是否继承了不允许被继承的类（被  final 修饰的类）。

  * 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 

  * 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的  final 字段，或者出现
    不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。

  * ……
* 第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在与《Java 语言 
    规范》定义相悖的元数据信息。

##### 字节码验证

* 第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class 文件中的 Code 属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为.

##### 符号引用验证

* 最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。
* 符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java 虚拟机将会抛出一个` java.lang.IncompatibleClassChangeError` 的子类异常，典型的如:`java.lang.IllegalAccessError`、`java.lang.NoSuchFieldError`、 
  `java.lang.NoSuchMethodError` 等。

