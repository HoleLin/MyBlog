---
title: Java多线程-Happens-Before规则
date: 2021-06-11 22:07:30
cover: /img/cover/Java.jpg
tags:
- Happens-Before
- 多线程
categories:
- Java
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 参考文献

* Java并发编程实战
* 极客时间:Java并发编程实战
* [指令重排、happens-before规则](https://blog.csdn.net/u012834750/article/details/71606670)
* 《Java并发编程的艺术》

### Happens-Before规则

> happens-before规则规定了**对共享变量的写操作对其他线程可见**,它是可见性与有序性的一套规则总结,抛开happens-before规则,JVM并不能保证一个线程对共享变量的写,可让其他线程对该共享变量的读可见;
>
> 真正要表达的是：**前面一个操作的结果对后续操作是可见的**

#### 程序的顺序性规则

> 这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。这还是比较容易理解的，比如刚才那段示例代码，按照程序的顺序，第 6 行代码 “x = 42;” Happens-Before 于第 7 行代码 “v = true;”，这就是规则 1 的内容，也比较符合单线程里面的思维：**程序前面对某个变量的修改一定是对后续操作可见的。**

```java
// 以下代码来源于【参考1】
class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 42;
    v = true;
  }
  public void reader() {
    if (v == true) {
      // 这里x会是多少呢？
    }
  }
}
```

#### volatile 变量规则

> 这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。

#### 传递性

> 这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。
>
> <img src="http://www.chenjunlin.vip/img/thread/Happens-Before%E4%BC%A0%E9%80%92%E6%80%A7.png" alt="img" style="zoom:80%;" />
>
> 从图中，我们可以看到：
>
> * “x=42” Happens-Before 写变量 “v=true” ，这是规则 1 的内容；
>
> * 写变量“v=true” Happens-Before 读变量 “v=true”，这是规则 2 的内容 。
>
> 再根据这个传递性规则，我们得到结果：“x=42” Happens-Before 读变量“v=true”。
>
> 如果线程 B 读到了“v=true”，那么线程 A 设置的“x=42”对线程 B 是可见的。也就是说，线程 B 能看到 “x == 42” .这就是 1.5 版本对 volatile 语义的增强，这个增强意义重大，1.5 版本的并发工具包（java.util.concurrent）就是靠 volatile 语义来搞定可见性的
>
> 1） A happens-before B。
> 2） B happens-before C。
> 3） A happens-before C。
>
> 这里A happens-before B，但实际执行时B却可以排在A之前执行，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作(执行的结果)对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见，而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens-before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法，JMM允许这种重排序。

#### 管程中锁的规则

> 这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。

* **管程**是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现;

* 管程中的锁在 Java 里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。

  ```java
  synchronized (this) { //此处自动加锁
    // x是共享变量,初始值=10
    if (this.x < 12) {
      this.x = 12; 
    }  
  } //此处自动解锁
  ```

* 所以结合规则 4——管程中锁的规则，可以这样理解：假设 x 的初始值是 10，线程 A 执行完代码块后 x 的值会变成 12（执行完自动释放锁），线程 B 进入代码块时，能够看到线程 A 对 x 的写操作，也就是线程 B 能够看到 x==12。

#### 线程 start() 规则

> 这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。

* 换句话说就是，如果线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程 B），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作。具体可参考下面示例代码。

  ```java
  Thread B = new Thread(()->{
    // 主线程调用B.start()之前
    // 所有对共享变量的修改，此处皆可见
    // 此例中，var==77
  });
  // 此处对共享变量var修改
  var = 77;
  // 主线程启动子线程
  B.start();
  ```

####  线程 join() 规则

> 这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对**共享变量**的操作。

* 换句话说就是，如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。具体可参考下面示例代码。

  ```java
  Thread B = new Thread(()->{
    // 此处对共享变量var修改
    var = 66;
  });
  // 例如此处对共享变量修改，
  // 则这个修改结果对线程B可见
  // 主线程启动子线程
  B.start();
  B.join()
  // 子线程所有对共享变量的修改
  // 在主线程调用B.join()之后皆可见
  // 此例中，var==66
  ```

#### 程序中断规则

> 对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
>
> 一个线程A调用另一个另一个线程B的interrupt()都happens-before于线程A发现B被A中断（B抛出异常或者A检测到B的isInterrupted（）或者interrupted()）。

#### **对象终结规则**

> 对象的构造函数执行完成先于finalize()方法

#### 注意点

> 两个操作之间具有`happens-before关系`，并不意味着前一个操作必须要在后一个操作之前执行，happens-before仅仅要求前一个操作`(执行的结果)`对后一个操作可见，且前一个操作按顺序排在第二个操作之前。

### 重排序

> Java 语言规范规定了JVM线程内部维持顺序化语义，也就是说只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能 与代码的顺序不一致。这个过程通过叫做指令的重排序。
>
> 指令重排序存在的意义在于：JVM能够根据处理器的特性（CPU的多级缓存系统、多核处理器等）适当 的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。
>
> 重排序指的是：`编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段`。

* `如果两个操作访问同一个变量，且这两个操作中有一个为写操作`，此时这两个操作之间就存在`数据依赖性`。数据依赖分为下列3种类型：

  | 名称   | 代码示例       | 说明                        |
  | ------ | -------------- | --------------------------- |
  | 写后读 | a=1;<br />b=a; | 写一个变量之后,再读这个变量 |
  | 写后写 | a=1;<br />a=2; | 写一个变量,再写这个变量     |
  | 读后写 | a=b;<br />b=1  | 读一个变量之后,再写这个变量 |

* 上面情况，`只要重排序两个操作的执行顺序，程序的执行结果就会被改变`。而编译器和处理器可能会对操作做重排序，但是编译器和处理器在重排序时，会遵守`数据依赖性`，编译器和处理器`不会改变存在数据依赖关系的两个操作的执行顺序`。

  > 这里所说的`数据依赖性`仅针对`单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑`。

#### Memory Bank的划分

> 一般 Memory bank 是按cache address来划分的。比如 偶数adress 0×12345000 分到 bank 0, 奇数address 0×12345100 分到 bank1。

#### 重排序的种类

* **编译器优化的重排序**。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;
* **指令级并行的重排序**。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在`数据依赖性`，处理器可以改变语句对应机器指令的执行顺序。
* **内存系统的重排序**。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

![img](http://www.chenjunlin.vip/img/java/thread/%E9%87%8D%E6%8E%92%E5%BA%8F.png)

> 在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果。
> 在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

### as-if-serial语义

> as-if-serial语义的意思是：不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。所以编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。

