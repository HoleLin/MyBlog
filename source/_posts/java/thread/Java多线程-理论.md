---
title: Java多线程-理论
date: 2021-06-11 22:07:30
cover: /img/cover/Java.jpg
tags:
- 理论
- 多线程
categories:
- Java
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 参考文献

* [并发与并行的区别是什么?](https://www.zhihu.com/question/33515481)
* Java并发编程实战
* 极客时间:Java并发编程实战

### 进程与线程

* 进程基本上是相互独立的,而线程存在与进程内,是进程的一个子集;
* 进程拥有共享的资源,如内存空间等,供其内部的线程共享;
* 进程间通信较为复杂
  * 同一台计算机的进程通信称为IPC(Inter-process commuication);
  * 不同计算机之间的进程通信,需要通过网络,并遵守共同的协议,如HTTP
* 线程通信相对简单,因为它们共享进程内的内存(多个线程可以访问同一个共享变量);
* 线程更轻量,线程上下文切换成本一般要比进程上下文切换低;

### 并行与并发

> 单核CPU下,线程实际上还是串行执行的.操作系统中有一个组件做任务调度器,将CPU的时间片(Windows下时间片最小为15毫秒)分给不同的线程使用,只是由于CPU在线程间(时间片很短)的切换的非常快,人类感觉是同时运行的.
>
> * 总结为一句话: **微观串行,宏观并行**

* 一般会将这种线程轮流使用CPU的做法称为**并发(Concurrent)**;
* 多核CPU下,每个核Core都可以调度运行线程,这时候线程可以**并行(Parallel)**;
* **并发(Concurrent)是同一时间应对(dealing with)多件事情的能力;**
* **并行(Parallel)是同一时间动手做(doing)多件事情的能力;**

> 「并发」强调的是可以一起「出『发』」，「并行」强调的是可以一起「执『行』」
>
> * 顺序：上一个开始执行的任务完成后，当前任务才能开始执行,
>
> - 并发：无论上一个开始执行的任务是否完成，当前任务都可以开始执行
>
> （也就是说，A B 顺序执行的话，A 一定会比 B 先完成，而并发执行则不一定。）
>
> 与可以一起执行的并行（parallel）相对的是不可以一起执行的串行（serial）：
>
> * 串行：有一个任务执行单元，从物理上就只能一个任务、一个任务地执行
>
> * 并行：有多个任务执行单元，从物理上就可以多个任务一起执行
>
> （也就是说，在任意时间点上，串行执行时必然只有一个任务在执行，而并行则不一定。）
>
> 综上，并发与并行并不是互斥的概念，只是前者关注的是任务的抽象调度、后者关注的是任务的实际执行。而它们又是相关的，比如并行一定会允许并发。

<img src="http://www.chenjunlin.vip/img/thread/concurrent_parallel.jpg" alt="img" style="zoom:80%;" />

#### 弱并发

* 表现: 限制并发调用的数量,并非可用处理器资源,而是应用程序自身结构.

### 同步和异步

* 同步: 需要等待结果返回,才能继续运行;
* 异步: 无需等待结果返回,就能继续运行;

### 临界区与竞态条件

#### 临界区

> 在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。
>
> **临界资源**：**一次仅允许一个进程使用的资源**。例如：物理设备中的打印机、输入机和进程之间共享的变量、数据。
>
> **临界区**：每个进程中，**访问临界资源的**那段**代码**。

#### 竞态条件

> 多个线程在临界区内执行,由于代码的执行序列不同而导致结果无法预测,称之为发生了竞态条件;
>
> 当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。

#### 避免临界区的竞态条件的方式的解决方案

* 阻塞式的解决方案
  * `synchronized`
  * `Lock`
* 非阻塞式的解决方案
  * 原子变量

### 变量的线程安全分析

#### 成员变量和静态变量是否线程安全?

* 若它们没有共享,则是线程安全的;
* 若它们被共享,根据它们的状态是否能够改变,又分为两种情况:
  * 若只有读操作,则线程安全;
  * 若既有读操作又有写操作,则这段代码是临界区,需要考虑线程安全问题;

#### 局部变量是否线程安全?

* 局部变量是线程安全的;

* 但局部变量引用的对象,则未必

  * 若该对象没有逃离方法的作用范围,它们是线程安全的;

  * 若该对象逃离了方法的作用范围,则需要考虑线程安全;

    ```java
    // 不是线程安全的。虽然sb对象是在方法内生成的对象。但是sb作为一个返回变量返回，其他线程可以去拿取它，对它进行并发的操作
    public static StringBuilder method() {
    	StringBuilder sb = new StringBuilder();
    	sb.append(1);
    	sb.append(2);
    	return sb;
    }
    ```

