---
title:  Redis 面试题
date: 2021-05-30 16:33:33
index_img: /img/cover/Redis.jpg
tags: 
- Redis
- 面试题
categories: Redis
---
### Redis 面试题

* **参考文献**
  * [分布式系统架构面试题汇总（万字总结）](https://zhuanlan.zhihu.com/p/267712773)
  * [一张图搞懂Redis缓存雪崩、缓存穿透、缓存击穿](https://mp.weixin.qq.com/s/mDJ2tDlOX1UGRi_JuroLFw)

#### Redis雪崩问题

* **描述**

  >**现象**：大量key同一时间点失效，同时又有大量请求打进来，导致流量直接打在DB上，造成DB不可用。
  >
  >缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上，引起数据库压力过大甚至宕机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

* **解决方案**：

  * **加互斥锁** :跟缓存击穿解决思路一致，同一时间只让一个线程构建缓存，其他线程阻塞排队。

  * **缓存永不过期**:设置key永不失效（热点数据）；

  * **均匀过期**:设置key缓存失效时候尽可能错开(把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。)；

  * **双层缓存策略**:比如同时使用redsi和memcache缓存，请求->redis->memcache->db；

    > 使用主备两层缓存：
    >
    > 主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。
    >
    > 备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。

#### 缓存穿透问题

* **描述**

  > **现象**：用户大量并发请求的数据(key)对应的数据在redis和数据库中都不存在，导致尽管数据不存在但还是每次都会进行查DB。
  >
  > 为什么key对应数据在缓存和db中不存在还会每次都进行DB查询呢？因为很多开发同学写的代码写的逻辑都是先从redis缓存中查一把，如果缓存中为空则从DB中查，如果DB中查到的数据不为空则设置到缓存并返回给接口。那么问题来了，如果从DB中查询的数据为空呢？？

* **解决方案**：

  - 从DB中查询出来数据为空，也进行空数据的缓存，缓存时间设置短一点,或者该key对应的数据存在之后进行清理缓存,避免DB数据为空也每次都进行数据库查询；**缓存空对象**

    > 这种方法会存在两个问题：
    >
    > - 如果有大量的key穿透，缓存空对象会占用宝贵的内存空间。
    > - 空对象的key设置了过期时间，在这段时间可能会存在缓存和持久层数据不一致的场景。

  - 对一定不存在的key,进行过滤

  - 可以将所有可以能存在的key放到一个大的Bitmap中,查询时通过Bitmap过滤,或者使用**布隆过滤器**(Bloom Filter)，但是会增加一定的复杂度及存在一定的误判率；

    ```xml
    <dependencies>  
         <dependency>  
             <groupId>com.google.guava</groupId>  
             <artifactId>guava</artifactId>  
             <version>23.0</version>  
         </dependency>  
    </dependencies>  
    ```
    
    >  **布隆过滤器设计思想**
    >
    > 布隆过滤器由一个长度为m比特的位数组（bit array）与k个哈希函数（hash function）组成的数据结构。位数组初始化均为0，所有的哈希函数都可以分别把输入数据尽量均匀地散列。
    >
    > 当要向布隆过滤器中插入一个元素时，该元素经过k个哈希函数计算产生k个哈希值，以哈希值作为位数组中的下标，将所有k个对应的比特值由0置为1。
    >
    > 当要查询一个元素时，同样将其经过哈希函数计算产生哈希值，然后检查对应的k个比特值：如果有任意一个比特为0，表明该元素一定不在集合中；如果所有比特均为1，表明该集合有可能性在集合中。为什么不是一定在集合中呢？因为不同的元素计算的哈希值有可能一样，会出现哈希碰撞，导致一个不存在的元素有可能对应的比特位为1，这就是所谓“假阳性”（false positive）。相对地，“假阴性”（false negative）在BF中是绝不会出现的。
    >
    > 总结一下：布隆过滤器认为不在的，一定不会在集合中；布隆过滤器认为在的，可能在也可能不在集合中。
    >
    > **布隆过滤器优缺点**
    >
    > 优点：
    >
    > - 节省空间：不需要存储数据本身，只需要存储数据对应hash比特位
    > - 时间复杂度低：插入和查找的时间复杂度都为O(k)，k为哈希函数的个数
    >
    > 缺点：
    >
    > - 存在假阳性：布隆过滤器判断存在，可能出现元素不在集合中；判断准确率取决于哈希函数的个数
    > - 不能删除元素：如果一个元素被删除，但是却不能从布隆过滤器中删除，这也是造成假阳性的原因了
    >
    > **布隆过滤器适用场景**
    >
    > - 爬虫系统url去重
    > - 垃圾邮件过滤
    > - 黑名单

#### 缓存击穿

* **描述**

  > 缓存击穿是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，瞬间对数据库的访问压力增大。

* **缓存击穿危害**

  > 数据库瞬时压力骤增，造成大量请求阻塞。

* **解决方案**

  * **使用互斥锁（mutex key）**
  
    > 在查询缓存的时候和查询数据库的过程加锁，只能第一个进来的请求进行执行，当第一个请求把该数据放进缓存中，接下来的访问就会直接击中缓存，防止了缓存击穿。
  
  * **热点数据永不过期**
  
    > 永不过期实际包含两层意思：
    >
    > - 物理不过期，针对热点key不设置过期时间
    > - 逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建

#### 缓存预热

* **描述**

  > 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据回写到缓存。
  >
  > 如果不进行预热， 那么 Redis 初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。

* **操作方法**

  > - 数据量不大的时候，工程启动的时候进行加载缓存动作；
  > - 数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；
  > - 数据量太大的时候，优先保证热点数据进行提前加载到缓存。

#### Redis的淘汰删除策略

* Redis中通过`maxmemory`参数来设定内存的使用上限,如果Redis锁使用内存超过设定的最大值,那么会更根据配置文件中的策略选取要删除的key来删除,从而留出新的键值空间;在配置文件redis.conf 中，可以通过参数 `maxmemory <bytes>` 来设定最大内存：

* **主要有六种内存淘汰key方式**
  
  * `volatile-lru`:  利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) 。
  * `allkeys-lru`:利用LRU算法移除任何key （和上一个相比，删除的key包括设置过期时间和不设置过期时间的）。**通常使用该方式**。
  * `volatile-random`:移除设置过过期时间的随机key 。
  * `allkeys-random`: 随机移除一个key;
  * `volatile-ttl `:移除即将过期的key(minor TTL) 
* `noeviction`: 当内存使用达到阀值的时候满所有引起申请内存的命令会报错;
  
* **Redis过期时间判定**

  > 　在Redis内部，每当我们设置一个键的过期时间时，Redis就会将该键带上过期时间存放到一个**过期字典**中。当我们查询一个键时，Redis便首先检查该键是否存在过期字典中，如果存在，那就获取其过期时间。然后将过期时间和当前系统时间进行比对，比系统时间大，那就没有过期；反之判定该键过期。

* **过期删除策略**

  * **定时删除**

    > 　　在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。
    >
    > 　　优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。
    >
    > 　　缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。

  * **惰性删除**

    > 　　设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。
    >
    > 　　优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。
    >
    > 　　缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。

  * **定期删除**

    > 　　每隔一段时间，我们就对一些key进行检查，删除里面过期的key。
    >
    > 　　优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。
    >
    > 　　缺点：难以确定删除操作执行的时长和频率。
    >
    > 　　　　　如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。
    >
    > 　　　　　如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。
    >
    > 　　　　　另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。

* **Redis过期删除策略**

  > Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用。
  >
  > 　　**惰性删除**：Redis的惰性删除策略由 db.c/expireIfNeeded 函数实现，所有键读写命令执行之前都会调用 expireIfNeeded 函数对其进行检查，如果过期，则删除该键，然后执行键不存在的操作；未过期则不作操作，继续执行原有的命令。
  >
  > 　　**定期删除**：由redis.c/activeExpireCycle 函数实现，函数以一定的频率运行，每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。
  >
  > 　　注意：并不是一次运行就检查所有的库，所有的键，而是随机检查一定数量的键。
  >
  > 　　定期删除函数的运行频率，在Redis2.6版本中，规定每秒运行10次，大概100ms运行一次。在Redis2.8版本后，可以通过修改配置文件redis.conf 的 **hz** 选项来调整这个次数

#### Redis 哨兵模式原理

* **哨兵如何实现相互监督的功能**
  * 第一: 哨兵通过发布订阅\_sentinel_:hello channel来实现这个功能.每个哨兵每隔2s会想自己监控的所有主从Redis节点发送hello message,包括自己的IP,端口,运行ID,自己监控的Master节点IP,Master节点端口;
  * 第二: 所有主从Redis节点也会反馈这样的信息;

* **哨兵如何检测故障**

  * 第一: 某个哨兵节点判定Master节点故障,它会投出一票S_DOWN
  * 第二: 当有足够多的sentinel节点判定Master节点故障都投出S_DOWN票时,Master节点会被认为真正的下线了
  * 也就是**基于多数投票原则**

* **哨兵模式如何实现故障恢复**

  * 故障恢复需要完成如下几步操作:
    * 第一: 通过选主机制选择新的Master节点替换掉原来的故障节点;
    * 第二: 其他的节点称为Slave节点用于主从复制,也就是身份保持不变;
    * 第三: 告知客户端新的Master节点地址信息,同时执行必要的脚本来通知系统管理员;

* **选主机制**

  * **过程**

    > sentinel的选举过程基本上是Raft协议的实现，即所有节点会随机休眠一段时间，然后发起拉票，当某个节点获得的票数超过max(sentinel|/2 + 1), qurom时，该节点就被推选为leader节点。注意是哨兵去从节点里面选。

  * **选谁**

    > **①根据指定的优先级选择**
    >
    > 管理员在启动redis从节点的时候，指定了其优先级，哨兵会先从优先级高的从节点去选择。
    >
    > ②**根据数据更新程度选择**
    >
    > 优先级相同，所有slave节点复制数据的时候都会记录复制偏移量，值越大说明与master节点的数据更一致。所以哨兵会选择复制偏移量最大的节点。
    >
    > ③**根据runid选择：**
    >
    > 到了这一步节点的孰优孰劣就没什么区别了，每个节点启动的时候都会有一个唯一的runId, 那么我们就选择runid最小的节点好了。

#### **Redis缓存与数据库数据一致性**

* **描述**

  > 不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：
  >
  > 1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。
  >
  > 2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。
  >
  > 怎么保证缓存一致性？：读直接去缓存读，没有的话就读数据库，写直接写数据库，然后失效缓存中对应的数据

* **解决方案**

  * **第一种方案：延时双删策略+缓存超时设置**

    * 在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。

    * **具体步骤**

      > 1）先删除缓存；
      >
      > 2）再写数据库；
      >
      > 3）休眠一段时间；
      >
      > 4）再次删除缓存。
      >
      > **设置缓存过期时间**
      >
      > 所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。也就是看到写请求就执行上面的策略。

  * **第二种方案：异步更新缓存(基于订阅binlog的同步机制)**

    * MySQL binlog增量订阅消费+消息队列+增量数据更新到redis
    * 一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息通过消息队列推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。

#### Redis的热key问题如何解决

* **理论**

  > 所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。

* **发现热key**

  > **方法一**:凭借业务经验，进行预估哪些是热key 其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。
  >
  > 方法二:在客户端进行收集 这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。
  >
  > **方法三**:在Proxy层做收集 有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。
  >
  > **方法四:用Redis自带命令**
  >
  > (1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。
  >
  > (2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。
  >
  > **方法五:自己抓包评估**
  >
  > Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。

* **解决方案**

  > *  **利用二级缓存** 比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。
  >
  >   针对这种热key请求，会直接从jvm中取，而不会走到redis层。假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。
  >
  >   现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。
  >
  > * **备份热key** 这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。

#### Redis主从复制

* **理论**

  * 在Redis客户端通过`info replicaton`可以查看与复制相关的状态,对于了解主从节点的当前状态,以及解决出现的问题都会有帮助.

  > 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。
  >
  > 默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。

* **主从复制的作用:**

  * **数据冗余**：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
  * **故障恢复**：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
  * **负载均衡**：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
  * **高可用基石**：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

