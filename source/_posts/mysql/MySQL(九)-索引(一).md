---
title: MySQL(九)-索引(一)
mermaid: true
date: 2021-07-02 19:41:38
cover: /img/cover/MySQL.jpg
tags:
- 索引
categories:
- MySQL
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 参考文献

* 高性能MySQL(第三版)
* 极客时间--MySQL实战45讲

### 索引

#### 概念

* 关键字与数据的映射关系称为索引（包含关键字和对应的记录在磁盘中的地址）。关键字是从数据当中提取的用于标识、检索数据的特定内容。
* 索引的出现是为了提高查询的效率;
* 索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。
* 索引的原理很简单，就是把无序的数据变成有序的查询
  * 把创建了索引的列的内容进行排序
  * 对排序结果生成倒排表
  * 在倒排表内容上拼上数据地址链
  * 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据
* 索引检索为什么快？
  - 关键字相对于数据本身，数据量小
  - 关键字是有序的，二分查找可快速确定位置

### 索引操作

#### 创建索引

* 在创建表的时候对字段进行指定索引

  ```sql
  CREATE TABLE user_index (
  	id INT auto_increment PRIMARY KEY,
  	first_name VARCHAR ( 16 ),
  	last_name VARCHAR ( 16 ),
  	uuid VARCHAR ( 20 ) UNIQUE,
  	id_card VARCHAR ( 18 ),
  	information text 
  );
  ```

* 通过`alter table 表名 add 索引`更改表结构来添加索引

  ```sql
  -- 创建一个first_name和last_name的复合索引，并命名为name
  alter table user_index add key name (first_name,last_name);
  -- 创建一个id_card的唯一索引，默认以字段名作为索引名
  alter table user_index add UNIQUE KEY (id_card);
  -- 鸡肋，全文索引不支持中文
  alter table user_index add FULLTEXT KEY (information);
  ```

#### 查看索引

* 通过`desc 表名`展示表结构来查看索引信息

  ```sql
  mysql> desc user_index;
  +-------------+-------------+------+-----+---------+----------------+
  | Field       | Type        | Null | Key | Default | Extra          |
  +-------------+-------------+------+-----+---------+----------------+
  | id          | int         | NO   | PRI | NULL    | auto_increment |
  | first_name  | varchar(16) | YES  | MUL | NULL    |                |
  | last_name   | varchar(16) | YES  |     | NULL    |                |
  | uuid        | varchar(20) | YES  | UNI | NULL    |                |
  | id_card     | varchar(18) | YES  | UNI | NULL    |                |
  | information | text        | YES  | MUL | NULL    |                |
  +-------------+-------------+------+-----+---------+----------------+
  6 rows in set (0.07 sec)
  ```

* 通过`show create table 表名`展示建表语句来查看索引信息

  ```sql
  mysql> show create table user_index;
  +------------+--------------------------------------------------------------------------------------------------------------+
  | Table      | Create Table                                                                                                 |
  +------------+--------------------------------------------------------------------------------------------------------------+
  | user_index | CREATE TABLE `user_index` (
    `id` int NOT NULL AUTO_INCREMENT,
    `first_name` varchar(16) DEFAULT NULL,
    `last_name` varchar(16) DEFAULT NULL,
    `uuid` varchar(20) DEFAULT NULL,
    `id_card` varchar(18) DEFAULT NULL,
    `information` text,
    PRIMARY KEY (`id`),
    UNIQUE KEY `uuid` (`uuid`),
    UNIQUE KEY `id_card` (`id_card`),
    KEY `name` (`first_name`,`last_name`),
    FULLTEXT KEY `information` (`information`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
  +------------+--------------------------------------------------------------------------------------------------------------+
  1 row in set (0.08 sec)
  ```

* 通过`SHOW INDEXS FROM table_name\G;`

  ```mysql
  mysql> SHOW INDEX FROM	t;
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
  | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
  | t     |          0 | PRIMARY  |            1 | id          | A         |       97704 | NULL     | NULL   |      | BTREE      |         |               | YES     | NULL       |
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
  1 row in set (0.01 sec)
  ```

#### 删除索引

* 通过`alter table 表名 drop key 索引名称`

  ```sql
  alter table user_index drop KEY name;
  alter table user_index drop KEY id_card;
  alter table user_index drop KEY information;
  ```

* 删除主键索引：`alter table 表名 drop primary key`（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）

  ```sql
  mysql> alter table user_index drop primary key;
  1075 - Incorrect table definition; there can be only one auto column and it must be defined as a key
  ```

  * 若一定需要删除,则需要取消自增长在进行删除

  ```sql
  ALTER TABLE user_index MODIFY id INT;
  ALTER TABLE user_index DROP PRIMARY KEY;
  ```

#### 强制/忽略使用索引

```mysql
ALTER TABLE table_name ADD INDEX index_name ( index_fields );
-- 强制使用索引
SELECT	* FROM	table_name FORCE INDEX ( index_name ) WHERE  conditions;
-- 忽略使用索引
SELECT	* FROM	table_name IGNORE INDEX ( index_name ) WHERE conditions;
```

### 索引使用的数据结构

#### **哈希表**

> 通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。

* Hash算法是通过某中确定性的算法(比如MD5，SHA1，SHA2，SHA3)将输入变为输出。相同的输入永远可以得到相同的输出。
* 哈希表这种结构适用于**只有等值查询**的场景,`Memcached`以及其他一些`NoSQL`引擎;

##### **哈希索引**

* 好处: 因为索引自身只需要存储对应的哈希值,所以索引的结构十分紧凑,这样使得哈希索引查找的速度非常快.
* 限制:
  * 哈希索引只包含哈希值和行指针,而不存储字段值,所以不能使用索引中的值来避免读取行(即使用覆盖索引).不过,访问内存中的行的速度很快,所以大部分情况下这一定对性能的影响并不明显.
  * 哈希索引数据并不是按照索引值顺序存储的,所以也就无法用于排序.
  * 哈希索引也不支持部分索引列匹配查找,因为哈希索引始终是使用索引列的全部内容来计算哈希值的.
  * 哈希索引只支持等值比较查询,包括=,IN(),<=>(注意<>[不等]和<=>[空值等于]是不同的操作),也不支持任何范围查询.

#### **有序数组**

* 有序数组在**等值查询**和**范围查询**场景中的性能都非常优秀
* 有序数组索引只适用于**静态存储引擎**

#### **二叉搜索树**

* 查询数据的时间复杂度为O(log2n)

* 二叉搜索树的特点是每个节点左儿子小于父节点,父节点又小于右儿子;
* 时间复杂度为O(logN)

#### 平衡二叉搜索树(AVL)

* 当数据特殊时会退化为链表，查询数据的时间复杂度会变为O(n),为了解决种问题，人们提出了**平衡二叉搜索树(AVL)**，它在二叉搜索树的基础上增加了约束，每个节点的左子树和右子树的高度差不能超过1，也就是所节点的左子树和右子树任然是平衡二叉树

  * 常见的平衡二叉树有平衡二叉搜索树，红黑树，数堆，伸展树。搜索时间复杂度为O(log2n)
  * 数据查询的时间主要依赖磁盘I/O的次数，采用二叉树的形式，即使使用平衡二叉搜索树进行改进，树的深度也是O(log2n)，当n比较大时，深度也是比较高的。


#### B树

* 如果用二叉树作为索引的实现结构，会让树变得很高，增加磁盘的I/O次数，影响查询的时间，因此一个节点就不能只有2个子节点，应该允许有M个子节点(M>2).

  * **B树**的出现就是为了解决这个问题，B树全称Balance Tree也就是平衡的多路搜索树，它的高度小于平衡二叉树的高度。

  * 在文件系统和数据库系统中的索引经常采用B树来实现。

    ![img](https://www.holelin.cn/img/mysql/B%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

    * B树作为平衡的多路搜索树，它的每个节点最多可以包括M个节点，M称为B树的阶，同时每个磁盘中包括了关键字和子节点的指针。如果一个磁盘块中包括了x个关键字，那么指针数就是x+1.
    * 一个M阶的B树(M>2)有以下的特性：
      * 根节点的儿子树的范围是[2,M].
      * 每个中间节点包含k-1个关键字和k个孩子，孩子的数量=关键字的数量+1，k的取值范围为[ceil(M/2),M].
      * 叶子节点包括k-1关键字(叶子节点没有孩子)，k的取值范围为[ceil(M/2),M].
      * 假设中间节点的节点关键字为Key[1],Key[2]...Key[k-1],且关键字按照升序排序，Key[i]<Key[i+1].此时k-1个关键字相当于划分了k个范围，也就是对应着k个指针，即为P[1],P[2]....P[k],其中P[1]指向关键字小于Key[1]的子树,P[i]指向关键字属于(Key[i-1],Key[i])的子树，P[k]指向关键字大于Key[k-1]的子树。
      * 所有叶子节点位于同一层。

#### B+树

* **B+树性质**：
  - n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。
  - 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
  - 所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
  - B+ 树中，数据对象的插入和删除仅在叶节点上进行。
  - B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。

* **查询方式**：
  - 主键索引区:PI(关联保存的时数据的地址)按主键查询,
  - 普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快

  * B+树基于B树做出改进,B+树和B树差异在于以下几点:
  
    * 有k个孩子的节点就有k个关键字，也就是孩子数量=关键字数量，而B树中，孩子数量=关键字数量+1.
    * 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大(或最小)。
    * 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放到叶子节点中。而B树中，非叶子节点既保存索引，也保存数据。
    * 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小顺序链接。
  
  * B+树相对于B树的优点
  
    * B+树查询效率更稳定，因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。
    * B+树到查询效率更高，这是因为通常B+树比B树更矮胖(阶数更大，深度更低)，查询所需要的磁盘I/O也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。
    * 不仅在对单个关键字的查询上，在查询范围上，B+树的效率也比B树高。这是因为所有关键字都出现在B+树的叶子节点中，并通过有序链表进行链接，而在B树中则需要通过中序遍历才能完成范围的查找，效率要低很多。
  
* ##### B树与B+树区别

  - B树的**关键字和记录是放在一起的**，叶子节点可以看作外部节点，不包含任何信息；
  - B+树的非叶子节点中只有关键字和指向下一个节点的索引，**记录只放在叶子节点中**;*
  - 使用B树的好处
    - B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。
  - 使用B+树的好处
    - 由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间

* ##### Hash索引和B+树实现原理

  - Hash索引底层就是Hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据
  - B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。
  - Hash索引和B+树区别

  - hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。
- hash索引不支持使用索引进行排序(ORDER BY);
  - hash索引不支持模糊查询以及复合索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。
  - hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
  - hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。
  - 而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。

* 数据库为什么使用B+树而不是B树?

  - B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
  - B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；
  - B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
  - B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。
  - 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。
  - B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据;'

### 可以使用B-Tree索引的查询类型

* 全值匹配
  * 全值匹配指的是和索引中的所有列进行匹配.如索引Index(code,name),可以用于查询code为1001,姓名为张三的人

* 匹配最左前缀
  * 可以用于查询code为1002的人,即使用索引的第一列

* 匹配列前缀
  * 可以匹配某一列的值的开头部分,如查询code为10为前缀的所有人.

* 匹配范围值
  * 可以用于查询code为10001和20001之间的人

* 精确匹配某一列并范围匹配另外一列
  * 可以用于查询code为10001,name以张开头人

* 只访问索引的查询
  * 即查询只需要访问索引,而无须访问数据行,即覆盖索引.


### 索引分类

#### 从功能逻辑上来看

* 索引主要分为4种，**普通索引，唯一索引，主键索引，全文索引**.前三种索引都是一类索引，只不过对数据的约束性逐渐提升。

##### 普通索引

* 普通索引是基础索引，没有任何约束，主要用于提高查询效率。

  * 普通索引的查询过程: 查找到满足条件的第一个记录后,需要查找下一个记录,直到碰到第一个不满足条件的记录;

##### **唯一索引**

  > 索引列的值必须唯一，但允许有空值
  >
  > 唯一索引就是在普通索引的基础上增加了数据唯一性的约束，一张表中可以有多个唯一索引。
  >
  > * 唯一索引的查询过程: 对于唯一索引来说,由于索引定义了唯一性,查找到第一个满足条件的记录后,就会停止继续检索;

  * 示例

  ```sql
  CREATE TABLE user (
      id INT(10) UNSIGNED AUTO_INCREMENT,
      age int(3),
      name VARCHAR(200), 
      id_card varchar(32),
      PRIMARY KEY(id), 
      -- 单值索引   
      KEY (name),
      -- 唯一索引
      UNIQUE KEY (id_card)
  );
  
  -- 单独创建索引
  CREATE INDEX idx_user_id_card ON `user`(id_card);
  ```

##### **主键索引**

  > 设定为主键后数据库会**自动建立索引**，`Innodb`为聚簇索引,一个表只能有一个主键索引，但是可以有多个唯一索引。
  >
  > 主键索引在唯一索引的基础上增加了不为空的约束，即`NOT NULL`+`UNIQUE`，一张表里面最多只能有一个主键索引。

  * 示例

  ```sql
  -- 和表一起创建
  CREATE TABLE `user` (
      id INT(10) UNSIGNED AUTO_INCREMENT,
      PRIMARY KEY(id)
  );
  
  --单独创建主键索引
  ALTER TABLE `user` ADD PRIMARY KEY user(id);
  
  --删除主键索引
  ALTER TABLE `user` DROP PRIMARY KEY;
  ```

##### **全文索引**（`fulltext key`)

  > `MySQL`自带的全文索引只能用于`MyISAM`，并且只能对英文进行全文检索 （基本不用）

#### 按照物理实现方式划分

<img src="https://www.holelin.cn/img/mysql/InnoDB%E5%92%8CMyISAM%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="img" style="zoom: 67%;" />

##### **聚簇索引**

* 聚簇索引并不是一个单独的索引类型,而是一种数据存储方式.

* 具体的细节依赖于其实现方式,但InnoDB的聚簇索引实际上同一个结构中保存了B-Tree索引和数据行.当表有聚簇索引时,它的数据行实际上存放在索引的叶子页(leaf page)中.即**聚簇表示数据行和相邻的键值紧凑地存储在一起**,因为无法同时把数据行存放在两个不同的地方,所以一个表只能有一个聚簇索引(不过,覆盖索引可以模拟多个聚簇索引的情况)
* InnoDB通过主键聚簇数据,即主键列为聚簇索引.

##### **非聚簇索引**(二级索引/辅助索引)

> 将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，MyISAM通过`key_buffer`把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在`key buffer`命中时，速度慢的原因;

* Innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值.
* 二级索引叶子节点保存的不是指向行的物理位置的指针,而是行的主键值.

##### 聚簇索引与非聚簇索引的区别

* 聚簇索引的叶子节点存储的就是数据记录，非聚簇索引的叶子结点存储的是数据的位置，非聚簇索引不会影响数据表的物理存储顺序。

* 一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。
* 使用聚簇索引的时候，数据查询效率高，但是对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。

#### 按照字段个数划分

* 又可以分为**单值索引**和**联合索引**

##### **单值索引**

> 即一个索引只包含单个列，一个表可以有多个单列索引

* 示例

```sql
CREATE TABLE `user` (
    id INT(10) UNSIGNED AUTO_INCREMENT,
    age int(3),
    name VARCHAR(200), 
    PRIMARY KEY(id), 
    -- 单值索引   
    KEY (name)   
);

-- 单独创建单值索引
CREATE INDEX idx_user_name ON `user`(name);
```

##### **复合索引**

> 即一个索引包含多个列，存在最左匹配原则

* 示例

```sql
CREATE TABLE `user` (
    id INT(10) UNSIGNED AUTO_INCREMENT,
    age int(3),
    name VARCHAR(200), 
    department_id varchar(100),
    id_card varchar(32),
    PRIMARY KEY(id), 
    -- 单值索引   
    KEY (name),
    -- 唯一索引
    UNIQUE KEY (id_card),
    -- 复合索引
    KEY (name,age,department_id) 
);

--单独创建复合索引
CREATE INDEX idx_student ON `user`(name,age,department_id);
```

### 索引创建的选择

#### 创建索引和使用索引的三个原则

* 单行访问是很慢的.特别是在机械硬盘存储中(SSD的随机I/O要快很多,变更这一点任然成立).如果服务器从存储中读取一个数据块只是为了获取其中一行,那么就浪费了很多工作.最好读取的块中能包含尽可能多所需要的行.使用索引可以创建位置引用以提升效率.
* 按顺序访问范围数据是很快的,这有两个原因.第一,顺序I/O不需要多次磁盘寻道,所以比随机I/O要快很多.第二,如果服务器能够按需要顺序读取数据,那么就不在需要额外的排序操作,并且`GROUP BY`也无须再做排序和将行按组进行聚合计算了.
* 索引覆盖查询是很快的.如果一个索引包含了查询需要的所有列,那么存储引擎就不需要在回表查找行.

#### 不需要创建索引的情况

* WHERE条件（包括GROUP BY，ORDER BY）里用不到的字段不需要创建索引。

* 表记录太少，比如小于1000个

* 字段中如果有大量重复数据，也不用创建索引，如性别字段

  > 如性别、支付状态等状态值字段往往只有极少的几种取值可能，这种字段即使建立索引，也往往利用不上。这是因为，一个状态值可能匹配大量的记录，这种情况MySQL会认为利用索引比全表扫描的效率低，从而弃用索引。索引是随机访问磁盘，而全表扫描是顺序访问磁盘

* 频繁更新的字段不一定要创建索引，因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。

#### 前缀索引和索引选择性

* 语法：`alter table table_name add index index_name(field(10))`，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。
  * 使用前缀索引,定义好长度,就可以做到既节省空间,又不用额外增加太多的查询成本.
* 前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。
* 实操的难度：在于前缀截取的长度。
  * 我们可以利用`select count(*)/count(distinct left(password,prefixLen));`，通过从调整`prefixLen`的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前`prefixLen`个字符几乎能确定唯一一条记录）

##### 前缀索引对覆盖索引的影响

* 前缀索引无法使用覆盖索引对查询性能的优化.

##### 使用前缀索引的方式

* **使用倒序存储**
  * 若字符串前缀没有较大的区分度,则可以使用倒序的方式来存储,查询的时候按正序的方式来查询.需要进行转换一下.
* **使用hash字段**
  * 添加一个字段来保存hash码(`crc32`),同时在这个字段上创建索引
* **倒序存储和使用hash字段这两个方法的异同点**
  * 相同点
    * 是都不支持查询.倒序存储的字段上创建的索引是按照倒序字符串的方式排序,无法查询出字段在[x,y]区间的数据,hash字段的方式只能支持等值查询.
  * 不同点
    * 从占用的额外空间来看,倒序存储方式在主键索引上,不会消耗额外的存储空间,而hash字段方法需要增加一个字段.倒序存储方式使用4个字节的前缀长度应该是不够的,如果再长一点,这个消耗跟额外这个hash字段也差不多抵消.
    * 在CPU消耗方面,倒序方式每次写和读的时候,都需要额外调用一次`reverse`函数,而hash字段的方式需要额外调用一次`crc32()`函数.如果只从两个函数的计算复杂度来看的话,`reverse`函数额外消耗的CPU资源会更小些.
    * 从查询效率看,使用hash字段方式的查询性能相对更稳定一些.因为`crc32`算出来的值虽然有冲突的概率,但是概率很小,可以认为每次查询的平均扫描函数接近1.

##### 索引选择性

* 不重复的索引值(也称为基数,cardinality)和数据表的记录总数(#T)的比值,范围从1/#T到1之间.索引的选择性越高则查询效率越高,因为选择性高的索引可以让MySQL在查找时过滤更多的行.唯一索引的选择性是1,这是最好的索引选择性,性能也是最好的.

#### 覆盖索引

* 如果**要查询的字段都建立过索引**，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫覆盖索引。因此我们需要尽可能的在`select`后只写必要的查询字段，以增加索引覆盖的几率。

* 这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。

* 覆盖索引的好处

  * 索引条目通常远小于数据行大小,所以如果只需要读取索引,那么MySQL机会极大地减少数据访问量,这对缓存的负载非常重要,因为这种情况下响应时间大部分花费在数据拷贝上.
  * 索引是按照列值顺序存储的(至少在单个页内是如此),所以对I/O密级性的范围查询会比随机从磁盘读取每一行数据的I/O要少的多.
  * 由于InnoDB的聚簇索引,覆盖索引对于InnoDB特别有用,InnoDB的二级索引在叶子节点中保存了行的主键值,所有如果二级主键能够覆盖查询,则可以避免对主键索引的二次查询.

* 不是所有类型的索引都可以成为覆盖索引.覆盖索引必须要存储索引列的值,而哈希索引,空间索引和全文索引等都不存储索引列的值,所有MySQL只能使用B-Tree索引做覆盖索引.

* 当做索引覆盖查询是,在EXPLAIN的Extra列可以看到"Using index"的值.

* 索引覆盖查询还有很多陷阱可能导致无法实现优化.MySQL查询优化器会在执行前判断是否有一个索引能进行覆盖.假设索引覆盖了WHERE条件的字段,但不是整个查询涉及的字段,如果条件为假,MySQL5.5和更早的版本也总是会回表获取数据行,尽管并不需要这一行且最终会被过滤掉.

##### 延迟关联

  ```mysql
  EXPLAN SELECT * FROM products WHERE actor='SEAN CARREY' AND title like '%APOLLO%';
  ==>
  -- 先将索引扩展至覆盖三个数据量(actor,title,prod_id),然后改写查询
  EXPLAN SELECT * FROM products  JOIN (SELECT prod_id FROM products WHERE actor='SEAN CARREY' AND title like '%APOLLO%') AS t1 ON (t1.prod_id = products.prod_id);
  ```

  * 这种方式叫做**延迟关联(deferred join)**,因为延迟了对列的访问.在查询的第一阶段MySQL可以使用覆盖索引,在FROM子句的子查询中找到匹配的prod_id,然后根据这些prod_id值在外层查询匹配获取需要的所有列值.

### 索引优化

#### 单表查询优化(10个)

##### **全值匹配很快捷**

```sql
--建立复合索引（age, deptId, name）
CREATE INDEX idx_emp_ade ON t_emp(age, deptId, NAME);

--查找
EXPLAIN SELECT empno FROM t_emp WHERE age = 90;
EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1;
EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND name = '风清扬';

--和上一条SQL语句中WHERE后字段的顺序不同，但是不影响查询结果
EXPLAIN SELECT empno FROM t_emp WHERE deptId = 1 AND name = '风清扬' AND age = 90;
```

* **全值匹配很快捷指的是，查询的字段按照顺序在索引中都可以匹配到**

##### **最佳左前缀法则**

```sql
--先删除之前创建的单值索引
DROP INDEX idx_dept_id ON t_emp; 

--查询，未按照最佳左前缀法则
EXPLAIN SELECT empno FROM t_emp WHERE deptId = 1;
EXPLAIN SELECT empno FROM t_emp WHERE deptId = 1 AND name = '风清扬';

--查询，部分按照最佳左前缀法则（age字段和复合索引匹配，但name没有）
EXPLAIN SELECT empno FROM t_emp WHERE  age = 90 AND name = '风清扬';

--查询，完全按照最佳左前缀法则
EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1;
EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND name = '风清扬';
```

* **过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用**

* 在建立联合索引的时候,如何安排索引内的字段顺序?

  * 第一原则是,如果通过调整顺序,可以少维护一个索引,那么这个顺序往往就是需要优先考虑采用.

* **索引下推**

  ```mysql
  -- 找出名字第一个字为陈,而且年龄是21岁且性别为男的记录 name和age建立了索引
  select * from user where name like '陈%' and age=21 and ismale=1; 
  -- 四次回表
  -- name  age  ID      ID 	name	age	ismale
  -- 陈一		 		 3 ----> 3   陈一  21    1
  -- 陈二		 		 3 ----> 3   陈一  20    1
  -- 陈三		 		 3 ----> 3   陈一  10    2
  -- 陈四		 		 3 ----> 3   陈一  21    1
  
  -- 两次回表
  -- name  age  ID      ID 	name	age	ismale
  -- 陈一		21	 3 ----> 3   陈一  21    1
  -- 陈二		20	 3 --X-> 3   陈一  20    1
  -- 陈三		10	 3 --X-> 3   陈一  10    2
  -- 陈四		21	 3 ----> 3   陈一  21    1
  
  ```

  * 在MySQL5.6之前,只能从满足条件的第一条开始一个一个的回表,在主键索引上找出数据行,再对比字段值.
    * 先只根据name字段过滤出满足条件的记录,然后根据ID(主键)来回表查询并过滤;
  * 在MySQL5.6引入的索引下推优化(index condition pushdown),可以在索引遍历过程中,对索引中包含的字段先做判断,直接过滤不满足条件的记录,减少回表次数.
    * 根据name和age字段进行过滤满足条件的记录,然后根据ID(主键)来回表查询并过滤;

##### **索引列上不计算**

> 不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换），**可能会导致索引失效而转向全表扫描**

```sql
--直接查询
EXPLAIN SELECT empno FROM t_emp WHERE age = 90 AND deptId = 1 AND NAME = '风清扬';

--使用MySQL函数查询
EXPLAIN SELECT empno FROM t_emp WHERE LEFT(age,2) = 90 AND deptId = 1 AND name = '风清扬';
```

##### **范围之后全失效**

```sql
--范围查询
EXPLAIN SELECT empno FROM t_emp WHERE age > 50 AND deptId = 1 AND name = '风清扬';
EXPLAIN SELECT empno FROM t_emp WHERE age = 50 AND deptId > 1 AND NAME = '风清扬';

--未使用范围查询
EXPLAIN SELECT empno FROM t_emp WHERE age = 50 AND deptId = 1 AND name = '风清扬';
```

* **建议：**将可能做范围查询的字段的索引顺序**放在最后**
* **结论：使用范围查询后，如果范围内的记录过多，会导致索引失效**，因为从自定义索引映射到主键索引需要耗费太多的时间，反而不如全表扫描来得快

##### **覆盖索引多使用**

```sql
--查询所有字段
EXPLAIN SELECT * FROM t_dept WHERE id = 1;

--查询索引字段
EXPLAIN SELECT id FROM t_dept WHERE id = 1;
```

* **结论：使用覆盖索引（Using index）会提高检索效率**

##### **使用不等会失效**

> 在使用**不等于(!= 或者<>)时**，有时会无法使用索引会导致全表扫描

```sql
--SQL语句中有不等于
EXPLAIN SELECT * FROM t_emp WHERE age != 90;
EXPLAIN SELECT * FROM t_emp WHERE age <> 90;

--SQL语句中没有不等于
EXPLAIN SELECT * FROM t_emp WHERE age = 90;
```

##### **使用NULL值要小心**

> 在使用`IS NULL` 或者 `IS NOT NULL`时，可能会导致索引失效,但是如果**允许字段为空**，则
>
> * IS NULL 不会导致索引失效
> * IS NOT NULL 会导致索引失效

```sql
EXPLAIN SELECT * FROM t_emp WHERE age IS NULL;

EXPLAIN SELECT * FROM t_emp WHERE age IS NOT NULL;
```

##### **模糊查询加右边**

> 要使用模糊查询时，**百分号最好加在右边，而且进行模糊查询的字段必须是单值索引**

```sql
--创建单值索引
CREATE INDEX idx_emp_name ON t_emp(NAME);

--进行模糊查询
EXPLAIN SELECT * FROM t_emp WHERE name LIKE '%风';
EXPLAIN SELECT * FROM t_emp WHERE name LIKE '风%';
EXPLAIN SELECT * FROM t_emp WHERE name LIKE '%风%';
```

```sql
-- 有时必须使用其他类型的模糊查询，这时就需要用覆盖索引来解决索引失效的问题
EXPLAIN SELECT name FROM t_emp WHERE name LIKE '%风';
EXPLAIN SELECT name FROM t_emp WHERE name LIKE '风%';

EXPLAIN SELECT NAME FROM t_emp WHERE name LIKE '%风%';
```

* **结论：对索引进行模糊查询时，最好在右边加百分号。必须在左边或左右加百分号时，需要用到覆盖索引来提升查询效率**

##### **字符串加单引号**

> 当字段为字符串时，查询时必须带上单引号。否则**会发生自动的类型转换**，从而发生全表扫描

```sql
--使用了单引号
EXPLAIN SELECT card_id FROM person WHERE card_id = '1';

--未使用单引号，发生自动类型转换
EXPLAIN SELECT card_id FROM person WHERE card_id = 1;
```

##### **尽量不用or查询**

> 如果使用or，可能导致索引失效。所以要减少or的使用，可以**使用 union all 或者 union 来替代**

```sql
--使用or进行查询
EXPLAIN SELECT * FROM t_emp WHERE age = 90 OR NAME = '风清扬';
```

* 口诀

  > 全职匹配我最爱，最左前缀要遵守
  >
  > 带头大哥不能死，中间兄弟不能断
  >
  > 索引列上少计算，范围之后全失效
  >
  > LIKE 百分写最右，覆盖索引不写*
  >
  > 不等空值还有 OR，索引影响要注意
  >
  > VARCHAR 引号不可丢，SQL 优化有诀窍

#### 关联查询优化

##### **LEFT JOIN优化**

* 在优化关联查询时，只有在**被驱动表上建立索引才有效**
* left join 时，左侧的为驱动表，**右侧为被驱动表**

##### **INNER JOIN优化**

* **结论**：inner join 时，**mysql 会把小结果集的表选为驱动表**（小表驱动大表）

  **所以最好把索引建立在大表（数据较多的表）上**

##### **RIGHT JOIN优化**

* 优化类型和LEFT JOIN类似，只不过被驱动表变成了左表

#### 排序分组优化

> 在查询中难免会对查询结果进行排序操作。进行排序操作时要**避免出现 Using filesort**，应使用索引给排序带来的方便

##### **ORDER BY 优化**

* **结论**：

  要想在排序时使用索引，避免 Using filesort，首先需要发生**索引覆盖**，其次

  - ORDER BY 后面字段的顺序要和复合索引的**顺序完全一致**
  - ORDER BY 后面的索引必须按照顺序出现，**排在后面的可以不出现**
  - 要进行升序或者降序时，**字段的排序顺序必须一致**。不能一部分升序，一部分降序，可以都升序或者都降序
  - 如果复合索引前面的**字段作为常量**出现在过滤条件中，**排序字段可以为紧跟其后的字段**

