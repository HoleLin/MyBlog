---
title: MySQL(九)-索引(二)
date: 2021-07-09 16:35:31
cover: /img/cover/MySQL.jpg
tags:
- 索引
categories:
- MySQL
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 参考文献

* 高性能MySQL(第三版)

* 极客时间--MySQL实战45讲

### 在InnoDB表中按主键顺序插入行

* 如果正在使用InnoDB表并且没有什么数据需要聚集,那么可以定义一个代理键(surrogate key)作为主键,这种主键的数据应该和应用无关,最简单的方法是使用`AUTO_INCREMENT`自增列.这样可以保证数据行是按顺序写入,对于根据主键做关联操作的性能也会更好.
* 最好避免随机的(不连续且值的分布范围非常大)聚簇索引,特别是对于I/O密集型的应用.
* **使用自增的整数ID作为主键**,因为主键的值是顺序的,所以InnoDB把每一条记录都存储在上一条记录的后面.当达到页的最大填充因子时(InnoDB默认的最大填充因子时页大小的15/16,留出部分空间用于修改),下一条记录就会写入新的页中.一旦数据按照这种顺序的方式加载,主键页就会近似于被顺序的记录填满.
* **使用UUID聚簇索引的作为主键**,因为新行的主键值不一定比之前插入的大,所以InnoDB无法简单地总是把新行插入到索引的最后,而是需要为新的行寻找合适的位置(通常是已有数据的中间位置),并且分配空间.这样会增加很多额外工作,并导致数据分布不够优化.包括以下缺点:
  * 写入的目标页可能已经刷到磁盘上并从缓存中移除,或者是还没有被夹在到缓存中,InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中.这样导致大量的随机I/O
  * 因为写入是乱序的,InnoDB不得不频繁地做页分裂操作,以便为新的行分配空间.页分裂会导致移动大量数据,一次插入最少需要修改三个也不是一个页.
  * 由于频繁的页分裂,页会变得稀疏并被不规则填充,所以最终数据会有碎片.
* **所以在使用InnoDB时应该尽可能地按主键顺序插入数据,并且尽可能使用单调增加的聚簇键的值来插入新行.**

### 减少索引和数据碎片

* B-Tree索引可能会碎片化,这会降低查询的效率,碎片化的索引可能会以很差或者无序的方式存储在磁盘上.根据设计,B-Tree需要随机磁盘访问才能定位到叶子页,所以随机访问是不可避免的.然而,如果叶子在物理分布上是顺序且紧凑,那么查询的性能就会更好,否则,对于范围查询,索引覆盖扫描等操作来说,速度可能会降低很多倍.
* 表的数据存储也可能碎片化,然而,数据存储的碎片化比索引更加复制.有三种类型

#### 行碎片(Row fragmentation)

* 这种碎片指的是数据行被存储在多个地方的多个片段中.即使查询只从索引中访问一行记录,行碎片也会导致性能下降.

#### 行间碎片(Intra-row fragmentation)

* 行间碎片是指逻辑上顺序的页,或者行在磁盘上不是顺序存储的.行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大的影响,因为这些操作原本能够从磁盘上顺序存储的数据获益.

#### 剩余空间碎片(Free space fragmentation)

* 剩余空间碎片是指数据页中有大量的空余空间.这会导致服务器读取大量不需要的数据,从而造成浪费.

* 对于MyISAM表,这三类碎片化都可能发生,但InnoDB不会出现短小的行碎片,InnoDB会移动短小的行并重写到一个片段.
* 可以使用`OPTIMIZE TABLE`或者导出再导入的方式重新整理数据.

### InnoDB的索引模型

> 在InnoDB中,表都是根据主键顺序以索引的形式存储,这种存储方式的表称为索引组织表.InnoDB使用B+树索引模型,所以数据都是存储在B+树中的;
>
> 每个索引在InnoDB里面对应一个B+树;

#### 索引类型

* **主键索引**
  * 主键索引的叶子节点存在是整行数据.在InnoDB里,主键索引也称为聚簇索引(clustered index);
* **非主键索引**
  * 非主键索引的叶子节点的内容是主键值.在InnoDB里,非主键索引也被称为二级索引(secondary index);

![img](https://www.holelin.cn/img/mysql/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png)

#### 基于主键索引和普通索引的查询有什么区别?

* 若语句`SELECT * FROM T WHERE ID = 50`,即主键查询方式,则只需要搜索ID这颗B+树;
* 若语句`SELECT * FROM T WHERE k = 5`,即普通索引查询方式,则需要先搜索k索引树,得ID的值为500,再到ID索引树搜索一次,这个过程称为回表.也就是说,基于非主键索引的查询需要多扫描一颗索引树.
* **主键长度越小,普通索引的叶子节点就越小,普通索引占用空间越小**

#### 索引维护

* B+树为了维护索引有序性,在插入新值的时候需要做必要维护.若在上图插入新的ID值为700,则只需要在R5的记录后面插入一个新记录.若新插入的ID值为400,就相对麻烦,需要逻辑上挪动后面的数据,空出位置.

* 若R5所在的数据页已经满了,根据B+树的算法,这时候需要申请一个新的数据页,然后挪动部分数据过去,这过程称为**页分裂**;
  * 除了性能外,页分裂操作还影响数据页的利用率.原本放在一个页的数据,现在分到两个页中,整体空间利用率降低了大约50%.
  * 有分裂就有合并.当相邻两个页由于删除了数据,利用率很低之后,会将数据页做合并.合并的过程,可以认为分裂过程中的逆过程.

##### 自增主键的使用场景

* 自增主键是指自增列上定义的主键,在建表语句中一般定义为:`NOT NULL PRIMARY KEY AUTO_INCREMENT`
* 插入新记录的时候可以不指定ID的值,系统会获取当前ID最大值加1作为下一条的ID值.即自增主键的插入数据模式,符合递增插入的场景,每次插入一条新记录,都是追加操作,都不涉及到挪动其他记录,也不会触发叶子节点分裂.
  * 而有些业务逻辑的字段做主键,则往往不容易保证有序插入,这样写数据成本相对较高.
    * 适合业务字段直接做主键的场景?
      * 要求只有一个索引,该索引必须是唯一索引.
* **主键长度越小,普通索引的叶子节点就越小,普通索引占用的空间也就越小.**

#### 索引片和过滤因子

* 索引片就是SQL查询语句在执行中需要扫描的一个索引片段,根据索引片中包含的匹配列的数量不同,将索引分成**窄索引**(比如包含索引列数为1或2)和**宽索引**(包含的索引列数大于2)
  * 若索引片越宽,则需要顺序扫描的索引页就越多;
  * 若索引片越窄,则会减少索引访问的开销;
  * 每个非聚簇索引保存的数据都会存储主键值,然后通过主键值,来回表查找对应的数据,因此每个说因都相当与包括了主键.
  * 宽索引能够避免二次的随机 IO，而窄索引就需要在对索引进行顺序读取之后再根据主键 id 从主键索引中查找对应的数据
  * 对于窄索引，每一个在索引中匹配到的记录行最终都需要执行另外的随机读取从聚集索引中获得剩余的数据，如果结果集非常大，那么就会导致随机读取的次数过多进而影响性能。
* 过滤因子:它描述了谓词的选择性.在WHERE条件语句中,每个条件都称为一个谓词,谓词的选择性也等于满足这个条件列的记录数除以总记录数的比例.
  * 过滤因子决定了索引片的大小,过滤因子的条件过滤能力越强,满足条件的记录数就越少,SQL查询需要扫描的索引片也就越小.

#### 理想索引设计: 三星索引

* 三星索引具体指的是
  * 在WHERE条件语句中,找到所有等值谓词中的条件列,将它们作为索引中的开始列;
  * 将GROUP BY和ORDER BY 中的列加入到索引中.
  * 将SELECT字段中剩余的列加入到索引片中.

* 三星索引的逻辑
  * 最小化碎片
  * 避免排序
  * 避免回表查询

### Change buffer

* 当需要更新一个数据页时,如果数据页在内存中就直接更新,而如果这个数据页还没有在内存中的话,在不影响数据一致性的前提下,InnoDB会将这些更新操作换成在change buffer中,这样就不需要从磁盘中读入这个数据页了.在下次查询需要访问这个数据也的时候,将数据页读入内存,然后执行change buffer中与这个页有关的操作.通过这种方式就能保证这个数据逻辑的正确性.
* 需要说明的是,虽然名字叫做change buffer,实际上它是可以持久化的数据.也就是说change buffer在内存中有拷贝,也会被写入到磁盘上.
* 将change buffer中的操作应用到原数据页,得到最新结果的过程称为merge.除了访问这个数据页会触发merge外,系统有后台现场会定期merge.在数据库正常关闭(shutdown)的过程中,也会执行merge操作.
  * merge的执行流程
    * 从磁盘读入数据页到内存(老版本的数据页);
    * 从change buffer里找出这个数据页的change buffer 记录(可能有多个),依次应用得到新版数据页;
    * 写redo log.这个redo log包含了数据的变更和change buffer的变更;
  * 到这里merge过程就结束了,这时候,数据页和内存中change buffer对应的磁盘位置都还没有修改,属于脏页,之后各自刷回自己的物理数据,就是另外一个过程了.
* 显然,如果能够将更新操作先记录在change buffer,减少随机磁盘访问,语句的执行速度会得到明显的提示.而且数据读入内存是需要占用buffer pool的,所以这种方式还能够避免占用内存,提高内存利用率.

#### 什么条件下可以使用change buffer呢?

* 对于唯一索引来说,所有的更新操作都要先判断这个操作是否违反唯一性约束.比如,要对插入的记录,就要先判断现在表中是否已经存在了这条记录,而这必须要将数据页读入内存才能判断.如果都已经读入到内存中了,那直接更新内存会更快,就没必要使用change buffer了.
* 因此,唯一索引的更新就不能使用change buffer,实际上也只有普通索引可以使用.
* change buffer用的是buffer pool里的内存,因此不能无限增大.change buffer的大小,可以通过参数`innodb_change_buffer_max_size`来动态设置.这个参数设置为50的时候,表示change buffer的大小最多只能占用buffer pool的50%.

#### 在一张表中插入一条新记录,InnoDB的处理流程是怎样的?

* 第一种情况是,**这个记录是要更新的目标也在内存中**.

  * 对于唯一索引来说,找到要插入的位置,判断到没有冲突后,插入这个值,语句执行结束.
  * 对于普通索引来说,找到要插入的位置,插入这个值,语句执行结束.
  * 普通索引和唯一索引对更新语句的性能影响的差别,只是一个判断,只会耗费微小的CPU的时间.

* 第二种情况是,**这个记录要更新的目标页不在内存中**.

  * 对于唯一索引来说,需要将数据页读入内存,判断到没有冲突后,插入这个值,语句执行结束;

  * 对于普通索引来说,则是将更新记录在change buffer,语句执行就结束了.

#### change buffer的使用场景

* Change buffer只限于用在普通索引的场景下,而不适用于唯一索引.

##### 普通索引的所有场景,使用change buffer都可以起到加速作用吗?

* 因为merge的时候是真正进行数据更新的时刻,而change buffer的主要目的就是将记录的变更动作缓存下来,所以在一个数据页做merge之前,change buffer记录的变更越多(也就是这个页面上要更新的次数越多),受益就越大.
  * 因此,对于写多读少的业务来说,页面在写完以后马上被访问到的概率比较小,此时change buffer的使用效果最好.这种业务模型常见的就是账单类,日志类的系统.
  * 反之,假设一个业务的更新模式是写入之后马上会做查询,那么即使满足了条件,将更新先记录在change buffer,但之后由于马上要访问这个数据页,会立即触发merge过程.这样随机访问I/O的次数不会减少,反而增加了change buffer的维护代价.所以,对于这种业务模式来说,change buffer反而起到了副作用.

#### 索引的选择

* 普通索引和唯一索引应该怎么选择,其实这两类索引在查询能力上是没差别的,主要考虑的是对更新性能的影响.所以建议尽量选择普通索引.
* 若所有的更新后面,都马上伴随着对这个记录的查询,那么应该关闭change buffer.而其他情况下,change buffer都能提升更新性能.

#### change buffer 和 redo log的区别

* redo log主要节省的是随机写磁盘的IO消耗(转成顺序写)
* change buffer主要节省的则是随机读磁盘的IO消耗.

