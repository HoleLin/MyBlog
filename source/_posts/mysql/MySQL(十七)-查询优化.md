---
title: MySQL(十七)-查询优化
date: 2021-12-12 13:10:28
cover: /img/cover/MySQL.jpg
tags:
- 查询优化
categories:
- MySQL
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 参考文献

* 高性能MySQL(第三版)

### 慢查询

#### 慢查询基础

* 查询性能低下最基本的原因是访问的数据太多.某些查询可能不可避免地需要筛选大量数据,但这并不常见.大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化,对于低效的查询,可以通过下面两个步骤分析:

  * 确认应用程序是否在检索大量超过需要的数据.这通常意味着访问了太多的行,但有时候是访问了太多的列.
  * 确认MySQL服务器层是否在分析大量超过需要的数据行.
  
* 错误案例

  * **查询不需要的记录**

    * 常见的错误是误以为MySQL会只返回需要的数据,实际上MySQL却是先返回全部结果集在进行计算.开发者习惯使用这样的技术,先使用SELECT语句查询大量的结果,然后获取前面的N行后关闭结果集.他们认为MySQL会执行查询,并只返回他们需要的N条数据,然后停止查询.实际上是MySQL会查询出全部的结果集,客户端应用程序会接受全部的结果集数据,然后抛弃其中大部分数据.**最简单有效的解决方法是在这样的查询后面加上LIMIT**
    
  * 多表关联时返回全部列
  
    * 正确的方式是一个只取需要的列.
    
  * 总是取出全部列
    * `SELECT *`.取出全部列,会让优化器无法完成索引覆盖扫描这类优化,还会为服务器带来额外的I/O,内存和CPU的消耗.
    
  * 重复查询相同的数据
  
#### MySQL是否在扫描额外的记录

* 对于MySQL,最简单的衡量查询开销的三个指标如下
  * 响应时间
  * 扫描行数
  * 返回行数
* 没有哪个指标能够完美衡量查询的开销,但它们大致反映了MySQL在内部执行查询时需要访问多少数据,并可以大概推算出查询运行的时间.这个三个指标都会记录到MySQL的慢查询日志中,可以检查慢查询日志记录是找出扫描行数过多的查询的好办法.

##### 响应时间

* 响应时间是两个部分之和:服务时间和排队时间.
  * 服务时间是指数据库处理这个查询真正花费了多长时间.
  * 排队时间是指服务器因为等待某些资源而没有真正执行查询的时间,可能是等待I/O操作完成,也可能是等待行锁等等.

##### 扫描行数和返回行数

* 理想情况下扫描行数和返回行数应该是相同的,但实际上并不多.

##### 访问类型

* EXPLAIN语句中的type列反应了访问类型.
* 一般MySQL能够使用如下三种方式应用WHERE条件,从好到坏依次为
  * 在索引中使用WHERE条件来过滤不匹配的记录.这是在存储引擎层完成的.
  * 使用索引覆盖扫描(在Extra列中出现了Using index)来返回记录,直接从索引中过滤不需要的记录,并返回命中的结果.这是MySQL服务器层完成的,但无须再回表查询记录.
  * 从数据表返回数据,然后过滤不满足条件的记录(在Extra列中出现Using Where).这是在MySQL服务器层完成,MySQL需要先从数据表读出记录然后过滤.
* 如果发现查询扫描了大量的数据但只返回少数的行,那么通常可以尝试下面的技巧去优化它:
  * 使用索引覆盖扫描,把所有需要用的列都放在索引中,这样存储引擎无须回表获取对应行就可以返回结果了.
  * 改变库表结构,例如使用单独的汇总表.
  * 重写这个复杂的查询,让MySQL优化器能够以更优化的方式执行这个查询.

### 重构查询的方式

#### 切分查询

* 有时候对于一个大查询需要分而治之,将大查询切分成小查询,每个查询功能完全一样,只完成一小部分,每次只返回一小部分查询结果.
* 列如:删除旧数据,如果使用一个大的语句一次性完成的话,则可能需要一次性锁住很多数据,占满整个事务日志,耗尽系统资源,阻塞很多小的但很重要的查询.可以将一个大的DELETE语句切分成多个较小的查询可以尽可能小地影响MySQL性能,同时还可以减少MySQL复制的延迟.

#### 分解关联查询

```mysql
SELECT * FROM tag 
	JOIN tag_post ON tag_post.tag_id=tag.id
	JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
==>
SELECT * FROM tag_post WHERE tag_id='1';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id in (123,456,789,213,1223);
```

* 分解关联查询的方式的优势:
  * 让缓存的效率更高.许多应用程序可以方便地缓存单表查询对应的结果对象.例如第一个查询若被缓存了,那应用就可以跳过第一个查询;若id为123,456的内容已经被缓存,则可以少查几个ID.
  * 将查询分解后,执行单个查询可以减少锁的竞争.
  * 在应用层做关联,可以更容易对数据库进行拆分,更容易做到高性能和可扩展.
  * 查询本身效率也可能会有所提升.这个例子中,使用IN()代替关联查询,可以让MySQL安装ID顺序进行查询,这可能比随机的关联要更高效.
  * 可以减少冗余记录的查询.在应用层做关联,意味着对于某条记录应用只需要查询一次,而在数据库中关联查询,则可能需要重复地访问一部分数据.从这点看,这样的重构还可能会减少网络和内存的消耗.
  * 更进一步,这样做相当于在应用中实现了哈希关联,而不是使用MySQL的嵌套循环关联.某些场景哈希关联的效率要高很多.

### MySQL查询语句的执行流程

<img src="https://www.holelin.cn/img/mysql/MySQL%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img" style="zoom:67%;" />

* 大体来说,MySQL可分为**服务层**和**存储引擎层**两部分
  * Server层包括连接器,查询缓存,分析器,优化器,执行器等,涵盖MySQL的大多数核心服务功能,以及所有的内置函数(如日期,时间,数字和加密函数等)
  * 而在存储引擎层负责的数据存储和提取.其架构模式是插件式的,支持InnoDB,MyISAM,Memory等多个存储引擎.现在最常用的存储引擎是InnoDB,它是从MySQL5.5.5版本看是称为默认存储引擎.

#### MySQL通信协议

* MySQL客户端和服务端之间的通信协议是**半双工**的,这意味着,在任何一个时刻,要么是由服务器向客户端发送数据,要么是有客户端向服务器发送数据,这两个动作不能同时发生,所以我们无法将一个消息切成小块独立来发送.

  * 这种协议让MySQL通信简单快速,但是也从很多地方限制了MySQL.一个明显的限制是,没办法进行流量控制.一旦一段开始发送消息,另外一端要接收完整个消息才能响应它.

  * 客户端用一个单独的数据包将查询传给服务器.这也是为什么当查询的语句很长的时候,参数`max_allowed_packet`就特别重要了.一旦客户端发送了请求,它能做的事情就只是等待结果了.

  * 当客户端从服务器取数据时,看起来是一个拉数据的过程,但实际上是MySQL在向客户端推送数据的过程.客户端不断地接收服务器推送的数据,客户端也没办法让服务器停下来.

* 多数连接MySQL的库函数默认一般是获得结果集并缓存到内存中.MySQL通常协议等待所有的数据都已经发送客户端才能释放这条查询所占用的资源,所以接收全部结果并缓存通常可以减少服务器的压力,让查询能够早点结束,早点释放相应的资源.

#### 连接器

* 连接器负责跟客户端建立连接,获取权,维持和管理连接.连接命令一般为`mysql -h$ip -P$port -u$user -p`

  * 连接命令中的mysql是客户端工具,用来跟服务端建立连接.在完成经典的TCP握手后,连接器开始验证身份,此时用的就是输入的用户名和密码

    * 若用户名或密码不对,你就会收到一个"Access denied for user"的错误,然后客户端程序结束执行.
    * 若用户名密码通过认证,连接器会到权限表里面查询出当前登录的账号拥有的权限,之后,这个连接里面的权限判断逻辑,都将依赖于此时读取到的权限.
      * 这就意味着,一个用户的成功创建连接后,即使用管理员账号对这个用户的权限做了修改,也不会影响已经存在连接的权限.修改完成后,只有再新建的连接才会使用新的权限设置.

  * 连接完成后,如果没有后续的动作,这个连接就处于空闲状态(Command列显示为Sleep),可以通过`show processlist`命令中看到

    ```mysql
    mysql> show processlist;
    +------+-----------------+-----------+------+---------+---------+------------------------+------------------+
    | Id   | User            | Host      | db   | Command | Time    | State                  | Info             |
    +------+-----------------+-----------+------+---------+---------+------------------------+------------------+
    |    5 | event_scheduler | localhost | NULL | Daemon  | 1905442 | Waiting on empty queue | NULL             |
    | 2042 | root            | localhost | NULL | Query   |       0 | init                   | show processlist |
    | 2043 | holelin         | localhost | NULL | Sleep   |       4 |                        | NULL             |
    +------+-----------------+-----------+------+---------+---------+------------------------+------------------+
    3 rows in set (0.00 sec)
    ```

    * 若客户端太长时间没动静,连接器就会自动断开.这个时间由参数`wait_timeout`控制的,默认值是8小时;

      ```mysql
      mysql> show variables like 'wait_timeout';
      +---------------+-------+
      | Variable_name | Value |
      +---------------+-------+
      | wait_timeout  | 28800 |
      +---------------+-------+
      1 row in set (0.02 sec)
      ```

    * 若在连接被断开之后,客户端再次发送请求的话,就会收到一个错误提示:`Lost connetction to MySQL server during query`,若要继续,则需要重连,重新执行请求.

* 数据库里面,**长连接**是指连接成功后,如果客户端持续有请求,则一直使用同一个连接.**短连接**则是指每次执行完很少的几次查询后就断开连接,下次查询再重新建立一个.

  * 建立连接的过程通常是比较复杂的,所以在使用中尽量减少建立连接的动作,也尽量使用长连接.但是若全部使用长连接会导致MySQL占用内存涨得特别快,因为在MySQL在执行过程中临时使用的内存是管理在连接对象里面的.这些资源会在连接断开的时候才释放.故而长连接积累下来,可能会导致内存占用太大,被系统强制杀掉(OOM),从现象来看就是MySQL异常重启了.

  * 解决方法:

    * 定期断开长连接.使用一段时间,或者程序里面判断执行过一个占用内存的大查询后,断开连接,之后要查询再重连.

    * 若使用MySQL5.7或更新版本,可以在每次执行一个比较大的操作后,通过执行`mysql_reset_connection`[C的函数]来重新初始化连接资源.

      * 这个过程不需要重连和重新做权限验证,但是会将连接恢复到刚刚创建完时的状态.

      > **mysql_reset_connection()影响以下与会话状态相关的信息：**
      >
      > * 回滚活跃事务并重新设置自动提交模式
      > * 释放所有的表锁
      > * 关闭或删除所有的临时表
      > * 重新初始化会话的系统变量值
      > * 丢失用户定义的变量设置
      > * 释放prepared语句
      > * 关闭handler变量
      > * 将last_insert_id()的值设置为0
      > * 释放get_lock()获取的锁
      > * 清空通过mysql_bind_param()调用定义的当前查询属性

#### 查询缓存

* 建立完连接后,就可以执行SQL语句了,进入第二步:查询缓存
* MySQL拿到一个查询请求后,会先到查询缓存中看看,之前是不是执行过这条语句.之前执行过的语句以及其结果可能会以`key-value`对的形式,被直接缓存在内存中.key是查询语句,value是查询结果.若能查询到则直接返回给客户端.
* **MySQL8.0将查询缓存功能移除了.**

#### 分析器--语法解析器和预处理

* 若没有命中查询缓存,就要真正执行语句了.首先MySQL需要知道你要做什么,因此需要对SQL语句做解析.
* 首先MySQL通过关键字将SQL语句进行解析,并生成一颗对应的解析树.MySQL解析器将使用MySQL语法规则验证和解析查询.例如验证是否使用错误的关键字,或者使用的关键字的顺序是否正确等.
  * 若语法不对,就会收到`You have an error in your SQL syntax;`的错误提示.一般关注`use near`后面的内容.
* 预处理器则根据MySQL规则进一步检查解析树是否合法,例如,将检查数据表和数据列是否存在,还会解析名字和别名,看看它们是否有歧义.
* 下一步预处理器会验证权限.这通常很快,除非服务器上有很多的权限配置.

#### 优化器-查询优化器

* 执行到这一步时,语法树被认为是合法的,并且由优化器将其转化为执行计划.一条查询可以有很多种执行方式,最后都返回相同的结果.优化器的作用就是找到这其中最好的执行计划.
* MySQL使用**基于成本的优化器**,它将尝试预测一个查询使用某种执行计划时的成本,并选择其中成本最小的一个.最初的最小单位是随机读取一个4K数据页的成本,后来(成本计算公式)变得更加复杂,并且引入了一些因子来估算某些操作的代价,如当执行一次WHERE条件比较的成本,.可以通过查询当前会话的`Last_query_cost`的值来得知MySQL计算的当前查询的成本.
* MySQL的查询优化器是一个非常复杂的部件,其优化策略可以简单的分为两种,一种是**静态优化**,一种是**动态优化**.
  * 静态优化可以直接对解析树进行分析,并完成优化.例如,优化器可以通过一些简单的代数变换将WHERE条件转换为另一种等价形式.静态优化不依赖于特别的数值,如WHERE条件中带入的一些常熟等.静态优化在第一次完成后就一直有效,即使使用不同的参数重复执行查询也不会发生变化.可以认为这种是一种'"编译时优化"
  * 动态优化可以认为是"运行是优化",在执行语句和存储过程的时候,动态优化和静态优化的区别非常重要.MySQL对查询的静态优化只需做一次,但对查询的动态优化则在每次执行时都需要重新评估.有时候升值在查询的执行过程中也会重新优化.

##### MySQL能够处理的优化类型

* **重新定义关联表的顺序**

  * 数据表的关联并不总是按照在查询中指定的顺序进行.决定关联的顺序是优化器很重要的一部分功能.

* **将外连接转化为内连接**

  * 并不是所有的OUTER JOIN语句都必须以外连接的方式执行.诸多因素,例如WHERE条件,库表结构都可能会让外连接等价于一个内连接.MySQL能够识别这点并重新查询,让其可以调整关联顺序.

* **使用等价变换规则**

  * MySQL可能使用一些等价变换来简化并规范表达式.它可以合并和减少一些比较,还可以移除一些恒成立和一些恒不成立的判断.

* **优化COUNT(),MIN()和MAX()**

  * 索引和列是否可以为空通常可以帮助MySQL优化这类表达式.如果MySQL使用了这种类型的优化,那么在EXPLAIN中就可以看到"Select tables optimized away".从字面意思可以看出,它表示优化器已经从执行计划中移除了该表,并以一个常数取而代之.

* **预估并转化为常数表达式**

  * 当MySQL检测到一个表达式可以转化为常数的时候,就会一直把该表达式作为常数进行优化处理.

* **覆盖索引扫描**

  * 当索引中的列包含所有查询中需要使用的列的时候,MySQL就可以使用索引返回需要的数据,而无须查询对应的数据行.

* **子查询优化**

  * MySQL在某些情况下可以将子查询转换一种效率更高的形式,从而减少多个查询多次对数据进行访问.

* **提前终止查询**

  * 在发现已经满足查询需求的时候,MySQL总是能够立刻终止查询.类似"不同值/不存在"的优化一般可用`DISTINCT`,`NOT EXIST()`或者`LEFT JOIN`类型的查询.

* **等值传播**

  * 如果两个列的值通过等式关联,那么MySQL能够把其中一个列的WHERE条件传递到另一列上.

    ```mysql
    SELECT film.film_id FROM sakila.film INNER JOIN sakila.film_actor USING(film_id) WHERE film.film_id > 500;
    ```

    * 这里使用film_id字段进行等值关联,MySQL知道这里的WHERE子句不仅适用于film表,而且对于film_actor表同样适用.

* **列表IN()的比较**

  * 在很多数据库系统中,IN()完全等同于多个OR条件的子句,因为这两者是完全等价的.但是在MySQL中这点是不成立的,MySQL将IN()列表中的数据先进行排序,然后通过二分查找的方式来确定列表中的值是否满足条件,这是一个O(logn)复杂度的操作,等价地转换成OR查询的复杂度为O(n),对于IN()列表中大量取值的时候,MySQL的处理速度将会更快.

##### 优化器扫描行数是怎么判断的

* MySQL在真正开始执行语句之前,并不能精确的知道满足这个条件的记录有多少条,而只能根据统计信息来估算记录数.
* 这个统计信息就是索引的"区分度".显然,一个索引上不同的值越多,这个索引的区分度就越好.而一个索引上不同的值的个数,被称为"基数"(cardinakity),也就是说,这个基数越大,索引的区分度越好.
* 可以使用`show index from table_name`,看到一个表中索引的基数.

##### MySQL是怎样得到索引的基础的呢?

* MySQL采用采样统计的方法.因为把整张表取出来一行一行的统计,虽然可以得到精确的结果,但是代价太高了,所以只能选择采样统计.
  * 采样统计的时候,InnoDB默认会选择N个数据页,统计这些页面上的不同值,得到一个平均值,然后乘以这个索引的页面数,就得到这个索引的基数.
  * 而数据表会持续更新的,索引统计信息也不会固定不变.所以当变更的数据行数超过`1/M`的时候,就会自动触发重新做一次索引统计.
* 在MySQL中,有两种存储索引统计的方式,可以通过设置参数`innodb_stats_persistent`的值来选择
  * 设置为on的时候,表示统计信息会持久化存储,这时,默认的N是20,M是10.
  * 设置为off的时候,表示统计信息只会存储在内存中.这时,默认的N是8,M是16.

#### 执行器

* 开始执行的时候,需要先判断一下当前连接是否拥有对该表的执行查询权限,若没有则会返回没有权限的错误;若有权限就打开表继续执行.打开表的时候,执行器就会根据表的引擎定义,去使用这个引擎提供的接口.
* 执行器的执行流程
  * 调用InnoDB引擎接口获取这个表的第一行,若满足条件则将该行存入结果集中;不满足则跳过
  * 调用引擎接口获取"下一行",重复相同的判断逻辑,直到取到这个表的最后一行.
  * 执行器将上述遍历过程中满足条件的行组成记录集作为结果集返回客户端.
* 数据库的慢查询日志中有一个`rows_examined`的字段,表示这个语句执行过程中扫描了多少行.这个值就是执行器每次调用引擎获取数据行的时候累加的.
  * 在有些场景下,执行器调用一次,在引擎内部则扫描了多行,因此引擎扫描行数跟`rows_examined`并不是完全相同的.
* 对于由于索引信息不准确导致的问题,可以使用`analyze table`来解决.
* 对于其他优化器误判的情况,可以在应用端用`force index`来强行指定索引,也可以通过修改语句来引导优化器,还可以通过增加或者删除索引来绕过这个问题.

#### 返回结果给客户端

* 查询执行到最后一个阶段是将结果返回给客户端.即使查询不需要返回结果集给客户端,MySQL仍然会返回这个查询的一些信息,如该查询影响到的行数.
* 结果集中的每一行都会以一个满足MySQL客户端/服务端通信协议的封包发送,再通过TCP协议进行传输,在TCP传输的过程中,可能对MySQL的封包进行缓存然后批量传输.

### MySQL如何执行关联查询

* MySQL关联执行的策略:MySQL对于任何关联都执行**嵌套循环关联**操作.

  * 即MySQL先在一个表循环取出单条数据,然后再嵌套循环到下一个表寻找匹配的行,依次下去,知道找到所有表中匹配的行为止.然后根据各个表匹配的行,返回查询中需要的各个列.MySQL会尝试在最后一个关联表中找到所有匹配的行,如果最后一个关联表无法找到更多的行以后,MySQL返回到上一层次关联表,看是否能够找到更多的匹配记录,依次类推迭代执行.

  ```mysql
  SELECT tab1.col1,tabl2.col2 FROM tabl1 INNER JOIN tabl2 USING(col3) WHERE tabl1.col1 IN (5,6);
  ==> 
  outer_iter = iterator over tabl1 WHERE col1 IN(5,6)
  outer_row = outer_iter.next
  while outer_row
  	inner_iter = iterator over tabl2 WHERE col3 = outer_row.col3
  	inner_row = inner_iter.next
  	while inner_row
  		output[ outer_row.col1,inner_row.col2 ]
  		inner_row = inner_iter.next
  	end
    outer_row = outer_iter.next
  end  
  ```

  ```mysql
  SELECT tab1.col1,tabl2.col2 FROM tabl1 LEFT OUTER JOIN tabl2 USING(col3) WHERE tabl1.col1 IN (5,6);
  ==> 
  outer_iter = iterator over tabl1 WHERE col1 IN(5,6)
  outer_row = outer_iter.next
  while outer_row
  	inner_iter = iterator over tabl2 WHERE col3 = outer_row.col3
  	inner_row = inner_iter.next
  	if inner_row
      while inner_row
        output[ outer_row.col1,inner_row.col2 ]
        inner_row = inner_iter.next
      end
    else
        output[ outer_row.col1,NULL ]
    end  
      outer_row = outer_iter.next
  end  
  ```

#### 执行计划

* 和很多其他关系数据库不同,MySQL并不会生成查询字节码来执行查询.MySQL是生成查询的一颗指令树,然后通过存储引擎执行完成这棵指令树并返回结果.最终的执行计划包含了重构查询的全部信息.如果对某个查询执行`EXPLAIN`后,再执行`SHOW WARNINGS`,就能看到重构的查询.

#### 关联优化器

* 关联优化器会尝试在所有的关联顺序中选择一个成本最小的来生成执行计划树.如果可能,优化器会遍历每一个表然后逐个做嵌套循环计算每一棵可能的执行计划树的成本,最后返回一个最优的执行计划.
* 糟糕的是,如果有超过n个表的关联,那么需要检查n的阶乘种关联顺序,这被称为所有可能的执行计划的"搜索空间",搜索空间的增长速度非常快.当搜索空间非常大的时候,优化器不可能逐一评估每一种关联顺序的成本.这时,优化器选择使用**贪婪搜索**的方式查找最优的关联顺序.实际上,当需要关联超过`optimzer_search_depth`的限制的时候,就会选择贪婪搜索模式.

### 在同一个表上查询和更新

* MySQL不允许对同一张表进行查询和更新.

  ```mysql
  -- 提示语法错误 1093 - You can't specify target table 'tabl' for update in FROM clause, Time: 0.000000s
  UPDATE tabl AS outer_tabl SET cnt = ( SELECT count(*) FROM tabl AS inner_tabl WHERE inner_tabl.type = outer_tabl.type );
  ```

* 可以通过使用生成表的形式来绕过上面的限制,因为MySQL只会把这个表当做临时表来处理.实际上这执行了两个查询: 一个子查询中的SELECT语句,另一个是多表关联UPDATE,只是关联的表是一个临时表.子查询会在UPDATE语句打开表之前就完成.

  ```mysql
  UPDATE tabl INNER JOIN (SELECT type,count(*) AS cnt FROM tabl GROUP BY type ) AS der USING(type) SET tbl.cnt = der.cnt;
  ```

### COUNT()作用

* COUNT()是一个特殊的函数,可以**统计某个列值的数量**,可以**统计结果集的行数**
  * 在统计列值时要求列值是非空的(**不统计NULL**),如果在COUNT()的括号中指定了列或者列的表达式,则统计的就是这个表达式的结果数.
  * 当MySQL确认括号内的表达式值不可能为空,实际上就是在统计行数,最简单的即使当我们使用COUNT(*)的时候,这种情况下通配符并不会像我们猜想的那样扩展成所有的列,实际上,它会忽略所有的列而直接统计所有的行数.
* COUNT(*),COUNT(1),COUNT(列名)的区别
  * 在InnoDB引擎下，COUNT(1)和COUNT(*)哪个快呢？结论是:这俩在高版本的MySQL(5.5及以后，5.1的没有考证)是没有什么区别的.
  * 如果该表只有一个主键索引，没有任何二级索引的情况下，那么COUNT(\*)和COUNT(1)都是通过通过主键索引来统计行数的。如果该表有二级索引，则COUNT(1)和COUNT(*)都会通过**占用空间最小的字段的二级索引**进行统计

