---
title: MySQL事务
mermaid: true
date: 2021-06-12 19:43:29
cover: /img/cover/MySQL.jpg
tags:
- 事务
categories:
- MySQL
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 事务

> 事务支持在引擎层实现的

#### 全局锁与表锁

> 数据库锁设计的初衷是处理并发问题.作为多用户共享的资源,当出现并发访问的时候,数据库需要合理地控制资源的访问规则.而锁就是用来实现这些访问规则的重要数据结构.
>
> 根据加锁的范围,MySQL里面的锁大致为**全局锁**,**表级锁**,**行锁**三类;

##### 全局锁

* 全局锁就是对整个数据库实例加锁.MySQL提供了一个加全局读锁的方法,命令是`FLUSH TABLES WITH READ LOCK`(**FTWRL**),使用这个命令后,其他线程的一下语句会被阻塞:
  * **数据更新语句(数据的增删改);**
  * **数据定义语句(包括建表,修改表结构等);**
  * **更新类事务的提交事务;**
* 全局锁的典型使用场景是:**做全库逻辑备份**.也就是把整库每个表都`SELECT`出来存成文本;
* 通过FTWRL确定不会其他线程对数据库做更新,然后对整个库做备份.注意,在整个备份过程中整个库完全处于**只读状态**;让整个库都只读会导致:
  * 若在主库备份,那么备份期间都不能执行更新,业务基本上就得停摆;
  * 若在从库备份,那么备份期间从库不能执行主库同步过来的`binlog`会导致主从延迟;
* 不加锁的haunted,备份系统备份得到的库不是逻辑时间点,这个视图是逻辑不一致的.

#### ACID

* Atomicity 原子性
* Consistency 一致性
* Isolation 隔离性
* Durability 持久性

#### 事务中可能出现的问题

* 脏读(dirty read)
* 不可重复读(non-repeatable read)
* 幻读(phantom read)

#### SQL标准的事务隔离级别

* 读未提交(read uncommited)

  > 一个事务还没提交时,它做的变更就能被别的事务看到;
  >
  > 别人改数据的事务尚未提交,我在我的事务中也能读到;

* 读提交(read commited)

  > 一个事务提交之后,他的变更才能被其他事务看到;
  >
  > 别人改数据的事务已提交,我在我的事务中才能读到;

* 可重复读(repeatable read)

  > 一个事务执行过程中看到的数据,总是跟这个事务在启动时看到的数据是一致.当然在可重复读隔离级别,未提交变更对其他事务也是不可见的;
  >
  > 别人改数据的事务已经提交,我在我的事务中也不去读;

* 串行(serializable)

  > 对于同一行记录,"写"会加"写锁","读"会加"读锁".当出现读写锁冲突的时候,后访问的事务必须等前一个事务执行完成,才能继续执行;
  >
  > 我的事务尚未提交,别人就不能改我的数据;

> Oracle默认隔离级别为"读提交"
>
> 在实现上,数据库里面会创建一个视图,访问的时候以视图的逻辑结果为准.
>
> * 在"可重复读"隔离级别下,这个视图是在事务启动是创建的,整个事务存在期间都用这个视图.
> * 在"读提交"隔离级别下,这个视图是在每个SQL语句开始执行的时候创建的.
> * 这里需要注意的是,"读未提交"隔离级别下直接返回记录上的最新值,没有视图的概念;
> * 而"串行化"隔离别下直接用加锁的方式来避免并行访问.

#### 设置事务隔离级别

> 参数设置: `trancsaction-isolation`设置为`READ-COMMITED`
>
> 事务的启动: 
>
> * 显示启动事务,`begin`或`start transaction`.配套的提交语句`commit`,回滚语句`rollback`;
> * `set autocommit=0`,这个命令会将线程的自动提交关掉;
