---
title: MySQL事务
mermaid: true
date: 2021-06-12 19:43:29
cover: /img/cover/MySQL.jpg
tags:
- 事务
categories:
- MySQL
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 事务

> 事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行;
>
> 事务支持在引擎层实现的;

#### 全局锁与表锁

> 数据库锁设计的初衷是处理并发问题.作为多用户共享的资源,当出现并发访问的时候,数据库需要合理地控制资源的访问规则.而锁就是用来实现这些访问规则的重要数据结构.
>
> 根据加锁的范围,MySQL里面的锁大致为**全局锁**,**表级锁**,**行锁**三类;

##### 全局锁

* 全局锁就是对整个数据库实例加锁.MySQL提供了一个加全局读锁的方法,命令是`FLUSH TABLES WITH READ LOCK`(**FTWRL**),使用这个命令后,其他线程的一下语句会被阻塞:
  * **数据更新语句(数据的增删改);**
  * **数据定义语句(包括建表,修改表结构等);**
  * **更新类事务的提交事务;**
* 全局锁的典型使用场景是:**做全库逻辑备份**.也就是把整库每个表都`SELECT`出来存成文本;
* 通过FTWRL确定不会其他线程对数据库做更新,然后对整个库做备份.注意,在整个备份过程中整个库完全处于**只读状态**;让整个库都只读会导致:
  * 若在主库备份,那么备份期间都不能执行更新,业务基本上就得停摆;
  * 若在从库备份,那么备份期间从库不能执行主库同步过来的`binlog`会导致主从延迟;
* 不加锁的haunted,备份系统备份得到的库不是逻辑时间点,这个视图是逻辑不一致的.

#### ACID

* **Atomicity 原子性**

  > 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用;

* **Consistency 一致性**

  > 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。

* **Isolation 隔离性**

  > 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。

* **Durability 持久性**

  > 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

#### 事务中可能出现的问题

* **脏读(Drity Read)**

  > 某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个事务RollBack了操作，则后一个事务所读取的数据就会是不正确的。**就是读到了别的事务回滚前的脏数据**,
  >
  > **当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。**

* **不可重复读(Non-repeatable Read)**

  > 在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
  >
  > **当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配.**

* **幻读(Phantom Read)**

  > 在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的
  >
  > **当前事务读第一次取到的数据比后来读取到数据条目不一致。**

#### SQL标准的事务隔离级别

![img](http://www.chenjunlin.vip/img/mysql/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png)

* **读未提交(Read Uncommitted)**

  * 一个事务还没提交时,它做的变更就能被别的事务看到;

  * 别人改数据的事务尚未提交,我在我的事务中也能读到;

  * 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

* **读提交(Read Committed)**

  * 一个事务提交之后,他的变更才能被其他事务看到;

  * 别人改数据的事务已提交,我在我的事务中才能读到;
  * 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

* **可重复读(Repeatable Read)**

  * 一个事务执行过程中看到的数据,总是跟这个事务在启动时看到的数据是一致.当然在可重复读隔离级别,未提交变更对其他事务也是不可见的;

  * 别人改数据的事务已经提交,我在我的事务中也不去读;
  * 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

* **串行(Serializable)**

  * 对于同一行记录,"写"会加"写锁","读"会加"读锁".当出现读写锁冲突的时候,后访问的事务必须等前一个事务执行完成,才能继续执行;
  
  * 我的事务尚未提交,别人就不能改我的数据;
  * 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

#### MySQL和Oracle默认隔离级别

* Oracle默认隔离级别为**Read Committed**隔离级别;
* MySQL 默认隔离级别为**Repeatable Read**隔离级别;

> 在实现上,数据库里面会创建一个视图,访问的时候以视图的逻辑结果为准.
>
> * 在"可重复读"隔离级别下,这个视图是在事务启动是创建的,整个事务存在期间都用这个视图.
> * 在"读提交"隔离级别下,这个视图是在每个SQL语句开始执行的时候创建的.
> * 这里需要注意的是,"读未提交"隔离级别下直接返回记录上的最新值,没有视图的概念;
> * 而"串行化"隔离别下直接用加锁的方式来避免并行访问.
>
> 事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。
>
> 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是Read-Committed(读取提交内容)，但是你要知道的是InnoDB 存储引擎默认使用 **Repeatable-Read（可重读）**并不会有任何性能损失。
>
> InnoDB 存储引擎在分布式事务的情况下一般会用到**Serializable(可串行化)**隔离级别。

#### 设置事务隔离级别

> 参数设置: `trancsaction-isolation`设置为`READ-COMMITED`
>
> 事务的启动: 
>
> * 显示启动事务,`begin`或`start transaction`.配套的提交语句`commit`,回滚语句`rollback`;
> * `set autocommit=0`,这个命令会将线程的自动提交关掉;

##### 查询MySQL全局事务隔离级别

```sql
select @@global.tx_isolation;
```

##### 查询当前会话事务隔离级别

```sql
 select @@tx_isolation;
```

