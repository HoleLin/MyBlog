---
title: HashMap
date: 2021-05-25 22:46:55
tags:
- Java
- JDK
- 源码
categories: 
- Java
---

#### HashMap源码

* 参考文献
  * [HashMap源码分析（jdk1.8，保证你能看懂）](https://zhuanlan.zhihu.com/p/79219960)

##### 理论

> HashMap最早是在JDK1.2中出现,直到JDK1.7一直没太大变化,但是到了JDK1.8突然进行了一个很大的改动.其中一个显著的改动就是:
>
> 之前JDK1.7的存储结构是数组+链表,到了JDK1.8变成了数组+链表+红黑树.
>
> 另外,HashMap是非线程安全的,也就是说多线程同时对HashMap中的某个元素进行增删改操作时,是不能保证数据的一致性的.

![image-20210417194922322](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210417194922322.png)

> 在JDK1.7中,首先是吧元素放在一个个数组里面,后来存放的数据元素越来越多,于是就出现了链表,对数组中的每个元素,都可以有一条链表来存储元素.这就是有名的"拉链式"存储方法
>
> 后来存储的元素越来越多,链表也越来越长,查找一个元素的时候效率不仅没有提高(链表不适合查找,适合增删),反而下降了不少,于是在JDK1.8中对这条链表进行了改进--使用红黑树. 将链表结构编程红黑树,原来JDK1.7的优点是增删效率提高,在JDK1.8中不仅增删的效率提高了,查找的效率也提升了.

![image-20210417195442294](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210417195442294.png)

* **链表变成红黑树的条件:只有链表的长度不小于8,而且数组的长度不小于64的时候才会将链表转化为红黑树.**

##### 为什么选择红黑树?

* 红黑树是一个自平衡的二叉查找树,也就是说红黑树的查找效率是非常高的,查找效率会从链表的O(n)降低为O(logn);

##### 为什么不一下子把整个链表转变为红黑树?

* 构造红黑树要比构造链表复杂,在链表的节点不多的时候,从整体的性能上看,数组+链表+红黑树的结构可能不一定比数组+链表的结构性能高;
* HashMap频繁的扩容,会造成底部红黑树不断的进行拆分和重组,这是非常耗时的,因此,也就是链表长度比较长的时候转变为红黑树才会效率显著;

##### 存储元素put

```java
public class Main {
    public static void main(String[] args) {
        Map<String, String> map = new HashMap<>();
        map.put("k1", "v1");
    }
}
```

  >（1）第一步：调用put方法传入键值对
  >（2）第二步：使用hash算法计算hash值
  >（3）第三步：根据hash值确定存放的位置，判断是否和其他键值对位置发生了冲突
  >（4）第四步：若没有发生冲突，直接存放在数组中即可
  >（5）第五步：若发生了冲突，还要判断此时的数据结构是什么？
  >（6）第六步：若此时的数据结构是红黑树，那就直接插入红黑树中
  >（7）第七步：若此时的数据结构是链表，判断插入之后是否大于等于8
  >（8）第八步：插入之后大于8了，就要先调整为红黑树，在插入
  >（9）第九步：插入之后不大于8，那么就直接插入到链表尾部即可。

![image-20210417201703380](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210417201703380.png)

##### 扩容

> HashMap扩容就是先计算,新的hash表容量和新的容量阀值,然后初始化新的hash表,将旧的键值对重新映射到新的hash表里面.若在就的hash表里面涉及到红黑树,那么在映射到新的hash表中还涉及红黑树的拆分.

![image-20210417204637243](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210417204637243.png)
#####  HashMap初始容量

* initialCapacity初始容量

  > 官方要求我们要输入一个2的N次幂的值，比如说2、4、8、16等等这些，但是我们忽然一个不小心，输入了一个20怎么办？没关系，虚拟机会根据你输入的值，找一个离20最近的2的N次幂的值，比如说16离他最近，就取16为初始容量。

##### HashMap负载因子

* loadFactor负载因子

  > 负载因子，默认值是0.75。负载因子表示一个散列表的空间的使用程度，有这样一个公式：initailCapacity*loadFactor=HashMap的容量。 所以负载因子越大则散列表的装填程度越高，也就是能容纳更多的元素，元素多了，链表大了，所以此时索引效率就会降低。反之，负载因子越小则链表中的数据量就越稀疏，此时会对空间造成烂费，但是此时索引效率高。
  >
  > 泊淞分布
  >
  > 当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。



