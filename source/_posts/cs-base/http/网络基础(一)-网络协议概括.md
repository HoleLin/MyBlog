---
title: 网络基础(一)-网络协议概述
date: 2021-07-23 22:37:57
index_img: /img/cover/Network.jpg
cover: /img/cover/Network.jpg
tags:
- HTTP
categories:
- CS Base
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 参考文献

* 编程必备基础 大话HTTP协议[慕课]
* [趣谈网络协议](https://time.geekbang.org/column/intro/85)
* WireShark数据包分析实战(第三版)
* [RFC793](https://www.ietf.org/rfc/rfc793.txt)
* TCP/IP详解 卷1: 协议

#### 基础概念

##### 协议三要素

* **语法**, 是解释控制信息每个部分的意义.就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。
* **语义**，是用户数据与控制信息的结构与格式.就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。
* **顺序(时序)**，是对事件发生顺序的详细说明,就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。

##### OSI七层模型

* OSI(**Open System Interconnection**,开放式系统互联),OSI参考模型从下往上依次是:(*物联网叔会试用*)
  * 物理层(**Physical Layer**):物理层复制传送比特(Bit),涉及到接口和传输媒体的机械,电气等特性.    **比特**      第七层  
  * 数据链路层(**Data Link Layer**): 数据链路层负责传送帧(**Frame**).                                                     **帧**          第六层 Ethernet,Token Ring,FDDI,AppleTalk
  * 网络层(**Network Layer**): 网络层负责路由,传送分组(**Packet**).												         **数据包**  第五层 IP,IPX
  * 传输层(**Transport Layer**): 传输层负责传送完整的报文(Message),并进行浏览控制和差错控制.  **数据段**  第四层 TCP,UDP,SPX
  * 会话层(**Session Layer**): 会话层负责建立,维护,终止会话连接,提供会话管理服务等.                       **数据**      第三层 NetBIOS,SAP,SDP,NWlink
  * 表示层(**Presentation Layer**): 表示层复制数据格式的转换.                                                              **数据**      第二层 ASCII,MPEG,JPEG,MIDI
  * 应用层(**Application Layer**): 应用层应用程序提供了接口,使应用程序接入到网络.                         **数据**       第一层 HTTP,SMTP,FTP,Telnet
* 七层模型的主要目的是为了解决异种网络互联所遇到的兼容性问题.
* 最大的优点就是将服务,接口,协议这三个概念明确的区分开来.
  * 服务说明某一层为上一层提供一些什么功能;
  * 接口说明上一层如何使用下层的服务;
  * 协议涉及如何实现本层的服务

##### HTTP

* 超文本传输协议(HTTP)是一种**通信协议**,它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器;
* HTTP是一个属于**应用层的面向对象的协议**,由于其简洁,快速的方式,适用于分布式超媒体信息系统,它于1990年提出,经过几年的使用与发展,得到不断地完善和扩展;

##### `TCP/IP`协议族分层

* `TCP/IP`协议族是有一个四层协议组成的系统,这四层分别为**应用层,传输层,网络层**和**数据链路层**;

###### 应用层

* 一般是我们编写的应用程序,决定了想用户提供应用服务.应用层可以通过系统调用传输层进行通信.如`FTP`,`DNS`,`HTTP`等;
* 应用层只需要专注与为用户提供应用功能,不用关心数据如何传递的.
* **应用层是在操作系统中的用户态,传输层及以下则在内核态**
* HTTP(超文本传输协议),FTP(文件传输协议),TFTP,SMTP(简单邮件传输协议),SNMP,DNS(域名系统)

###### 传输层

```tcl
       +------+ +-----+ +-----+       +-----+                    
       |Telnet| | FTP | |Voice|  ...  |     |  Application Level 
       +------+ +-----+ +-----+       +-----+                    
             |   |         |             |                       
            +-----+     +-----+       +-----+                    
            | TCP |     | RTP |  ...  |     |  Host Level        
            +-----+     +-----+       +-----+                    
               |           |             |                       
            +-------------------------------+                    
            |    Internet Protocol & ICMP   |  Gateway Level     
            +-------------------------------+                    
                           |                                     
              +---------------------------+                      
              |   Local Network Protocol  |    Network Level     
              +---------------------------+                      

                         Protocol Relationships
```

* 传输层通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能;
* 在传输层有两个性质不同的协议:`TCP`和`UDP`;
* TCP(传输控制协议 全双工),UDP(用户数据包协议),TCP相比UDP多了很多特性,比如流量控制,超时重传,拥塞控制等,这些都是为保证数据包能可靠地传输给对方.
* UDP就相对很简单,简单到只负责发送数据包,不保证数据包是否能抵达对方,但它实时性相对更好,传输效率也高.
* 应用层需要传输的数据可能会非常大,如果直接传输就不好控制,因此当传输层的数据包大小超过MSS(TCP最大报文段长度),就要将数据包分块,这样即使中途

###### 网络层

* 网络层用来处理在网络上流动的数据包,数据是网络传输的最小数据单位.该层规定了通过怎样的路径(传输路线)到达对方计算机,并把数据包传输给对方;
*  ICMP(网际控制报文协议),IGMP(网际组管理协议),IP(网际协议),ARP(地址解析协议),RARP(逆地址解析协议)

###### 数据链路层

* 链路层用来处理连接网络的硬件部分,包括控制操作系统,硬件设备驱动,`NIC`(Network Interface Card 网络适配器)以及光纤等物理可见部分.硬件上的范畴均在链路层的作用范围之内.

#### 网络硬件

##### 集线器

<img src="https://www.holelin.cn/img/cs-base/http/%E9%9B%86%E7%BA%BF%E5%99%A8.png" alt="img" style="zoom:50%;" />

* 集线器是工作在OSI参考模型**物理层**的转发设备.它从一个端口接收到数据包,然后将数据包传输(中继)到设备的每个端口上.
* 例如,如果一台计算机连接到一个4端口集线器的1号端口上,需要发送数据到连接在2号端口的计算机,那么集线器将会把数据发送给端口2,3,4.连接到3号端口与4号端口上的客户端通过检查以太网帧头字段中目标媒体访问控制地址(MAC),判断出这些数据包并不是给它们的,便丢弃这些数据包.
* 集线器会产生很多不必要的网络流量,并仅在半双工模式下运行(不能再同一时间发送和接收数据).在高密度的实际网络中,集线器最好的替代产品是交换机,它们是支持全双工的设备,可以同时发送和接收数据.

##### 交换机

<img src="https://www.holelin.cn/img/cs-base/http/%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt="img" style="zoom:50%;" />

* 与集线器相同,交换机也是用来转发数据包的,但与集线器不同的是,交换机并不是将数据广播到每一个端口,而是将数据发送到目的计算机所连接的端口上.
* 为了能够直接与一些特定的设备进行通信,交换机必须能够通过MAC地址来唯一标识设备,这意味着它们必须工作在OSI参考模型的**数据链路层**.
* 交换机将每个连接设备的2层地址都存储在一个CAM(Content Addressable Memory:内容寻址寄存器)表中,CAM表充当着一种类似交通警察的角色.
  * 当一个数据包被传输时,交换机读取数据包中的第二层协议头部信息,并使用CAM表作为参考,决定往哪个或者哪些端口发送数据包.交换机仅仅将数据包发送到特定的端口上,从而大大降低了网络流量.

##### 路由器

<img src="https://www.holelin.cn/img/cs-base/http/%E8%B7%AF%E7%94%B1%E5%99%A8.png" alt="img" style="zoom:50%;" />

* 路由器是一种比交换机或集线器具有更高层次功能的先进网络设备.
* 路由器工作在OSI参考模型的第3层,它们负责在两个或多个网络之间转发数据包.路由器在网络间引导数据包流向,这一过程被称为路由.路由器通常使用第3层地址(如IP地址)来唯一标识网络上的设备.

#### 流量分类

##### 广播

* 广播数据包会被发送到一个网段上的所有端口,而不管这些端口连接在集线器还是交换机上.但并非所有的广播流量都是通过相同方式构建的,而是包括第2层广播流量和第3层广播流量的两种主要形式.

  * 在第2层,MAC地址`FF:FF:FF:FF:FF:FF`是保留的广播地址,任何发送到这一地址的流量都将会被广播到整个网段.第3层也有着一些特定的广播地址.

* 在通过多个集线器或交换机连接多种媒介的大型网络中,广播数据包将从一个交换机一直被中继到另一个交换机上,从而传输到网络连接的所有网段上.广播数据包能够到达的区域被称为"广播域",也就是任意计算机可以不用经过路由器即可和其他计算机进行直接传输的网段范围.

  * 广播数据包只能在它特定的广播域中流通.

  ![img](https://www.holelin.cn/img/cs-base/http/%E5%B9%BF%E6%92%AD%E6%95%B0%E6%8D%AE%E5%8C%85.png)

##### 组播

* 组播是一种将单一来源数据包同时传输给多个目标的通信方式.组播的目的是简化这个过程,并使用尽可能少的网络带宽.
* 组播通过避免数据包的大量复制来达到优化效果,而对组播流量的处置方式则高度依赖于不同网络协议的实现细节.
* 实施组播的主要方法是通过一种将数据包接收者加入组播组的编址方案来实现的,这也是IP组播的工作原理.这种编址方案确保数据包不会被传送到未预期的目的地.事实上IP协议将一整段的地址都用于组播,如`224.0.0.0~239.255.255.255`的IP地址可能就是组播流量.

##### 单播

* 单播数据包会从一台计算机知直接传输到另一台计算机.单播机制的具体实现方式取决于使用的协议.

####  HTTP数据传输过程

* **数据封装(Data Encapsulation)**是将**协议数据单元**(PDU)封装在一组协议头和尾中过程.

![img](https://www.holelin.cn/img/cs-base/http/HTTP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png)

* 发送端发送数据时,数据会从上层传输到下层,且每经过一层都会被打上该层的头部信息.而接收端接收数据时,数据会从下层传输到上层,传输前会把下层的头部信息删除.
* 数据发送处理过程
  * 应用层将数据交给传输层,传输层添加上TCP的控制信息(称为TCP头部),这个数据单元称为段(Segment),加上控制信息的过程称为封装.然后将段交给网络层.
  * 网络层接收到段,再添加上IP头部,这个数据单元称为包(Packet).然后,将包交给数据链路层.
  * 数据链路层接收到包,再添加上MAC头部和尾部,这个数据单元称为帧(Frame).然后,将帧交给物理层.
  * 物理层将接收到的数据转化为比特流,然后在网线中传输.
* 数据接收处理过程
  * 物理层接收到比特流,经过处理后将数据交给数据链路层.
  * 数据链路层将接收到数据转化为数据帧,再除去MAC头部和尾部,这个除去控制信息的过程称为解封装,然后将包交给网络层.
  * 网络层接收到包,再除去IP头部,然后将段交给传输层.
  * 传输层接收到段,再除去TCP头部,然后将数据交给应用层.

#### `TCP`协议

#### TCP协议头

```sh
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            TCP Header Format
```

* Source Port:  16 bits The source port number.

* Destination Port:  16 bits The destination port number.

* Sequence Number:  32 bits 

  > The sequence number of the first data octet in this segment (except when SYN is present). If SYN is present the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.

* Acknowledgment Number:  32 bits

  > If the ACK control bit is set this field contains the value of the next sequence number the sender of the segment is expecting to receive.  Once a connection is established this is always sent.

* Data Offset:  4 bits

  > The number of 32 bit words in the TCP Header.  This indicates where the data begins.  The TCP header (even one including options) is an integral number of 32 bits long.

* Reserved:  6 bits

  > Reserved for future use.  Must be zero.

*  Control Bits:  6 bits (from left to right)

  ```
      URG:  Urgent Pointer field significant
      ACK:  Acknowledgment field significant
      PSH:  Push Function
      RST:  Reset the connection
      SYN:  Synchronize sequence numbers
      FIN:  No more data from sender
  ```

* Window:  16 bits

  > The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.

*   Checksum:  16 bits

#### `TCP`连接运行过程中状态

* LISTEN - represents waiting for a connection request from any remote TCP and port.
* SYN-SENT - represents waiting for a matching connection requestafter having sent a connection request.
* SYN-RECEIVED - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.
* ESTABLISHED - represents an open connection, data received can be delivered to the user.  The normal state for the data transfer phase of the connection.
* FIN-WAIT-1 - represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.
* FIN-WAIT-2 - represents waiting for a connection termination request from the remote TCP.
* CLOSE-WAIT - represents waiting for a connection termination request from the local user.
* CLOSING - represents waiting for a connection termination request acknowledgment from the remote TCP.
*  LAST-ACK - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).
* TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.
* CLOSED - represents no connection state at all.

#### `TCP`三次握手

<img src="https://www.holelin.cn/img/cs-base/http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="img" style="zoom:67%;" />

* 使用`TCP`协议进行通信的双方必须先建立连接,然后才能开始传输数据.为了确保连接双方可靠性,在双方建立连接时,`TCP`协议采用了三次握手策略;
* **第一次握手**: 客户端发送带有`SYN`标志的连接请求报文段,然后进入`SYN_SEND`状态,等待服务端的确认.
* **第二次握手**: 服务端接收到客户端的`SYN`报文段后,需要发送`ACK`信息

#### `TCP`四次挥手

![img](https://www.holelin.cn/img/cs-base/http/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

* 主动关闭连接的一方，调用close()；协议层发送FIN包
*  被动关闭的一方收到FIN包后，协议层回复ACK；然后被动关闭的一方，进入CLOSE_WAIT状态，主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作
*  被动关闭的一方在完成所有数据发送后，调用close()操作；此时，协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入LAST_ACK状态；
*  主动关闭的一方收到FIN包，协议层回复ACK；此时，主动关闭连接的一方，进入TIME_WAIT状态；而被动关闭的一方，进入CLOSED状态
*  等待2MSL时间，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态

##### 结论

* 主动关闭连接的一方 - 也就是主动调用socket的close操作的一方，最终会进入TIME_WAIT状态
*  被动关闭连接的一方，有一个中间状态，即CLOSE_WAIT，因为协议层在等待上层的应用程序，主动调用close操作后才主动关闭这条连接
*  TIME_WAIT会默认等待2MSL时间后，才最终进入CLOSED状态；
*  在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的！

#### `TCP`连接状态转换图

```
                              +---------+ ---------\      active OPEN  
                              |  CLOSED |            \    -----------  
                              +---------+<---------\   \   create TCB  
                                |     ^              \   \  snd SYN    
                   passive OPEN |     |   CLOSE        \   \           
                   ------------ |     | ----------       \   \         
                    create TCB  |     | delete TCB         \   \       
                                V     |                      \   \     
                              +---------+            CLOSE    |    \   
                              |  LISTEN |          ---------- |     |  
                              +---------+          delete TCB |     |  
                   rcv SYN      |     |     SEND              |     |  
                  -----------   |     |    -------            |     V  
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |<-----------------           ------------------>|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |<-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------                  
   |                  x         |     |     snd ACK                    
   |                            V     V                                
   |  CLOSE                   +---------+                              
   | -------                  |  ESTAB  |                              
   | snd FIN                  +---------+                              
   |                   CLOSE    |     |    rcv FIN                     
   V                  -------   |     |    -------                     
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |<-----------------           ------------------>|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |  
   | --------------   snd ACK   |                           ------- |  
   V        x                   V                           snd FIN V  
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |  
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |  
   |  -------              x       V    ------------        x       V  
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------>|TIME WAIT|------------------>| CLOSED  |
                              +---------+                   +---------+

                      TCP Connection State Diagram
```

![img](https://www.holelin.cn/img/cs-base/http/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)

##### `TIME_WAIT`状态

* `TIME_WAIT`状态也被称为`2MSL`等待状态.在该状态将会等待两倍于最大段生存期(Maximum Segment Lifetime,MSL)的时间

* 在Linux系统中,`net.ipv4.tcp_fin_timeout`的数值记录了`2MSL`状态需要等待的超时时间(以秒为单位)

  ```properties
  net.ipv4.tcp_fin_timeout = 2
  # 为1表示允许将TIME-WAIT的句柄重新用于新的TCP连接
  net.ipv4.tcp_tw_reuse = 1
  # 为1表示开启TCP连接中TIME-WAIT的快速回收，NAT环境可能导致DROP掉SYN包（回复RST）
  net.ipv4.tcp_tw_recycle = 1
  # 为1时SYN Cookies，当SYN等待队列溢出时启用cookies来处理，可防范少量SYN攻击
  net.ipv4.tcp_syncookies = 1
  # 当keepalive起用的时候，TCP发送keepalive消息的频度，单位为秒，缺省是7200秒（即2小时）
  net.ipv4.tcp_keepalive_time = 600
  #  端口最大backlog内核限制，防止占用过大内核内存
  net.ipv4.ip_local_port_range = 4000 65000
  net.ipv4.tcp_max_syn_backlog = 16384
  # 保持TIME_WAIT套接字的最大个数，超过这个数字TIME_WAIT套接字将立刻被清除并打印警告信息
  net.ipv4.tcp_max_tw_buckets = 36000
  net.ipv4.route.gc_timeout = 100
  #  对一个新建连接，内核要发送多少个SYN连接请求才决定放弃，不应该大于255
  net.ipv4.tcp_syn_retries = 1
  net.ipv4.tcp_synack_retries = 1
  net.core.somaxconn = 16384
  net.core.netdev_max_backlog = 16384
  # 不属于任何进程（已经从进程上下文中删除）的sockets最大个数，超过这个值会被立即RESET，并同时显示警告信息
  net.ipv4.tcp_max_orphans = 16384
  ```

* 假设已设定MSL的数值,按照规则:当TCP执行一个主动关闭并发送最终的ACK时,连接必须处于`TIME_WAIT`状态并持续两倍于最大生存周期(`2MSL`)的时间.这样能够让TCP重新发送最终的ACK以避免出现丢失的情况.重新发送最终的ACK并不是因为重传了ACK(它们并不消耗序列号,也不会被TCP重传),而是因为通信另一方重传了它的FIN(它消耗一个序列号).事实上,TCP总是重传FIN,直到它收到一个最终的ACK.

* 影响`2MSL`等待状态的因素是当TCP处于等待状态时,通信双方将该连接(客户端IP地址,客户端端口号,服务器IP地址,服务器端口号)(四元组)定义为不可重新使用.只有当`2MSL`等待结束时,或一条新连接使用的初始化序列号超过了连接之前的实例使用的最高序列号时,或者允许使用时间戳选项来区分之前连接实例的报文段以避免混淆时,这条连接才能被再次使用.不幸的是,一些实现施加了更加严格的约束,**在这些系统中,如果一个端口号被处于`2MSL`等待状态的任何通信端所用,那么该端口号将不能被再次使用.**

* 使用`ss -tan state time-wait | wc -l ` 查看`TIME_WAIT`的连接数量

#### ARP基础知识

* ARP(Address Resolution Protocol)地址解析协议是根据IP地址获取物理地址的一个TCP/IP协议.
* 由于OSI模型把网络分为七层,IP地址在OSI模型的第三层,MAC地址在第二层,彼此不能直接通信.在通过以太网发送IP数据包时,需要先封装第三层(32位IP地址),第二层(48为MAC地址)的报头.但由于发送数据包时只知道目标IP地址,不知道其MAC地址,而不能跨越第二层,所以需要使用地址解析协议.

* 使用地址解析后,计算机可根据网络层IP数据包包头中的IP地址信息对应目标硬件地址(MAC地址)信息,以保证通信的顺利进行.ARP的基本功能就是负责将一个已知的IP地址解析成MAC地址,以便主机能正常进行通信.

##### ARP工作流程

* ARP工作过程分为两个阶段:一个ARP请求过程,一个是ARP响应过程.
* 两台主机(PC1:192.168.1.1 PC2:192.168.1.2)详细通信过程:
  * 当主机PC1想发送数据给主机PC2时,首先在自己的本地ARP缓存表中检查主机PC2配置的MAC地址.
  * 如果主机PC1在缓存中没有找到相应的条目,它将询问主机PC2的MAC地址,从而将ARP请求帧广播到本地网络上的所有主机.该帧中包括员主机PC1的IP地址和MAC地址.本地网络上的每台主机都接收到了ARP请求并且检查是否与自己的IP地址匹配.如果主机发现请求的IP地址与自己的IP地址不匹配,它将会丢弃ARP请求.
  * 主机PC2确定ARP请求中的IP地址与自己的IP地址匹配,将主机PC1的地址和MAC地址添加到本地缓存表.
  * 主机PC2将包含其MAC地址的ARP回复消息直接发送回主机PC1(这个数据帧是单播).
  * 当主机PC1收到从主机PC2发来的ARP回复消息时,会将主机PC2的IP和MAC地址添加到自己的ARP缓存表.本机缓存是有生存期的,默认ARP缓存表的有效期是120s.当超过有效期后,将重复上面的过程.主机PC2的MAC地址一旦确定,主机PC1将能向主机PC2发送IP通信了.

##### ARP缓存表维护工具-arp命令

* 该命令用于查询本机ARP缓存中的IP地址和MAC地址的对应关系,添加或删除静态对应关系.

  ```sh
  ╭─ ~                                                            11:34:59 
  ╰ arp
  usage: arp [-n] [-i interface] hostname
         arp [-n] [-i interface] [-l] -a
         arp -d hostname [pub] [ifscope interface]
         arp -d [-i interface] -a
         arp -s hostname ether_addr [temp] [reject] [blackhole] [pub [only]] [ifscope interface]
         arp -S hostname ether_addr [temp] [reject] [blackhole] [pub [only]] [ifscope interface]
         arp -f filename
  * -s inet_addr eth_addr [if_addr]: 向ARP缓存表中添加可将IP地址inet_addr解析成物理地址eth_addr的静态条目.要向指定接口的表添加ARP缓存条目,使用if_addr参数,此处的if_addr代表指派给该接口的IP地址;
  * -d inet_addr if_addr: 删除指定的IP条目,此处的inet_addr代表IP地址.对于指定的接口,要删除表中的某项,使用if_addr,此处的if_addr代表指派给该接口的IP地址.要删除所有条目,使用星号(*)通配符代表inet_addr;
  * -a inet_addr[-N if_addr]: 显示所有接口的当前ARP缓存表.要显示特定IP地址的ARP缓存项,使用带有inet_addr参数的arp -a,此处的inet_addr代表IP地址.如果未指定inet_addr,则使用第一个适用的接口.要显示特定接口的ARP缓存表,将-N if_addr与-a参数一起使用,此处的if_addr代表指派给该接口的IP地址.-N参数区分大小写.
  * -v 查看帮助信息
  ```

#### ARP报文格式

<img src="https://www.holelin.cn/img/cs-base/http/ARP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="img" style="zoom:67%;" />

* 第一个字段是广播类型的MAC地址:`0XFF-FF-FF-FF-FF-FF`,其目的是网络上的所有主机.
* 第二个字段是源MAC地址,即请求地址解析的主机MAC地址.
* 第三个字段是协议类型
* 硬件类型:表明ARP协议实现在哪种类型的网络上.
* 协议类型:表示解析协议(上层协议).这里一般是0800即IP.
* 硬件地址类型长度:MAC地址长度,此处为6个字节.
* 协议地址长度:IP地址长度,此处为4个字节.
* 操作类型:表示ARP协议数据包类型
  * 1:表示ARP协议请求数据包
  * 2表示ARP协议应答数据包
* 源MAC地址:发送端MAC地址
* 源IP地址:表示发送端协议地址(IP地址)
* 目标MAC地址:目标MAC地址
* 目标IP地址:表示目标段协议地址(IP地址)

#### IP数据报首部格式

![img](https://www.holelin.cn/img/cs-base/http/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg)

* 版本号: 指IP协议所使用的版本.通信双方使用的IP协议版本必须一致.目前广泛使用的IP协议版本号为4,即IPv4.
* 首部长度:IP的首部长度,可表示的最大十进制数值是15.注意,该字段所表示的单位是32位字长(4字节).因此,当IP首部长度为1111(即十进制的15)时,首部长度就达到60字节.当IP分组的首部长度不是4字节的整数倍时,必须利用最后的填充字段加以填充.
* 服务类型:优先级标志位和服务类型标志位.被路由器用来进行流量的优先排序.
* 总长度:指IP首部和数据报中数据之后的长度,单位为字节.总长度字段为16位,因此数据报的最大长度为216-1=65535字节.
* 标识符:一个唯一的标识数字,用来识别一个数据报或者被分片数据包的次序.
* 标记:用来标记一个数据报是否是一组分片数据报的一部分.标志字段中的最低位记为MF(More Fragment).MF=1即表示后面"还有分片"的数据报.MF=0表示这个已是若干数据包分片中最后一个.标志字段中间的一位记为DF(Don't Fragment),意思是"不能分片".只有当DF=0时,才允许分片.
* 分片偏移:一个数据报是一个分片,这个域中的值就会被用来将数据报以正确的顺序重新组装.
* 存活时间:用来定义数据报的生成周期,以经过路由器的条数/秒数进行描述.
* 协议:用来识别在数据包序列中上层协议数据报的类型.
* 首部校验和:一个错误检测机制,用来确认IP首部的内容有没有被损坏或者被篡改.
* 源IP地址:发出数据报的主机的IP地址.
* 目的IP地址:数据报目的地IP地址.
* 选项:保留作额外的IP选项,它包含着源站选路和时间戳的一些选项.
* 数据:使用IP传递的实际参数.

##### `TTL`

* 存活时间(TTL)值定义了在该数据报被丢弃之前,所能经历的时间,或者能经过的最大路由数目.TTL在数据报被创建时就会被定义,而且通常在每次被发往一个路由器的时候减1.

##### IP分片

* 数据报分片是将一个数据流分为更小的片段,是IP用于解决跨域不同类型网络时可靠的一个特性.一个数据报的分片主要是基于第二层数据链路层所使用的最大传输单元(Maximum Transmission Unit MTU)的大小,以及使用这些二层协议的设备情况.在多数情况下,第二层所使用的最大数据报大小是1500字节(不包括14字节的以太网头本身).
* 当一个设备这边传输一个IP数据报时,它将会比较这个数据报的大小,以及将要把这个数据报传送出去的网络接口MTU,用于决定是否需要将这个数据报分片.如果数据报的大小大于MTU,那么这个数据报将会被分片.将一个数据报分片包括下列几个步骤:
  * 设备将数据分为若干个可成功进行传输的数据报.
  * 每个IP首部的总长度域会被设置为每个分片的片段长度.
  * 更多分片标志将会在数据流的所有数据报中设置为1,除了最后一个数据报.
  * IP头中分片部分的分片偏移将会被设置.
  * 数据报被发送出去.

##### 
