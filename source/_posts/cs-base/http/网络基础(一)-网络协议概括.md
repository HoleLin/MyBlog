---
title: 网络基础(一)-网络协议概述
date: 2021-07-23 22:37:57
index_img: /img/cover/Network.jpg
cover: /img/cover/Network.jpg
tags:
- HTTP
categories:
- CS Base
updated:
type:
comments:
description:
keywords:
top_img:
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
---

### 参考文献

* 编程必备基础 大话HTTP协议[慕课]
* [趣谈网络协议](https://time.geekbang.org/column/intro/85)
* WireShark数据包分析实战(第三版)
* [TCP-RFC793](https://www.ietf.org/rfc/rfc793.txt)
* TCP/IP详解 卷1: 协议
* 图解网络-小林coding
* [UDP-RFC768](https://www.ietf.org/rfc/rfc0768)

#### 基础概念

##### 协议三要素

* **语法**, 是解释控制信息每个部分的意义.就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。
* **语义**，是用户数据与控制信息的结构与格式.就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。
* **顺序(时序)**，是对事件发生顺序的详细说明,就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。

##### OSI七层模型

* OSI(**Open System Interconnection**,开放式系统互联),OSI参考模型从下往上依次是:(*物联网叔会试用*)
  * 物理层(**Physical Layer**):物理层复制传送比特(Bit),涉及到接口和传输媒体的机械,电气等特性.    **比特**      第七层  
  * 数据链路层(**Data Link Layer**): 数据链路层负责传送帧(**Frame**).                                                     **帧**          第六层 Ethernet,Token Ring,FDDI,AppleTalk
  * 网络层(**Network Layer**): 网络层负责路由,传送分组(**Packet**).												         **数据包**  第五层 IP,IPX
  * 传输层(**Transport Layer**): 传输层负责传送完整的报文(Message),并进行浏览控制和差错控制.  **数据段**  第四层 TCP,UDP,SPX
  * 会话层(**Session Layer**): 会话层负责建立,维护,终止会话连接,提供会话管理服务等.                       **数据**      第三层 NetBIOS,SAP,SDP,NWlink
  * 表示层(**Presentation Layer**): 表示层复制数据格式的转换.                                                              **数据**      第二层 ASCII,MPEG,JPEG,MIDI
  * 应用层(**Application Layer**): 应用层应用程序提供了接口,使应用程序接入到网络.                         **数据**       第一层 HTTP,SMTP,FTP,Telnet
* 七层模型的主要目的是为了解决异种网络互联所遇到的兼容性问题.
* 最大的优点就是将服务,接口,协议这三个概念明确的区分开来.
  * 服务说明某一层为上一层提供一些什么功能;
  * 接口说明上一层如何使用下层的服务;
  * 协议涉及如何实现本层的服务

##### `TCP/IP`协议族分层

* `TCP/IP`协议族是有一个四层协议组成的系统,这四层分别为**应用层,传输层,网络层**和**数据链路层**;

应用层

* 一般是我们编写的应用程序,决定了想用户提供应用服务.应用层可以通过系统调用传输层进行通信.如`FTP`,`DNS`,`HTTP`等;
* 应用层只需要专注与为用户提供应用功能,不用关心数据如何传递的.
* **应用层是在操作系统中的用户态,传输层及以下则在内核态**
* HTTP(超文本传输协议),FTP(文件传输协议),TFTP,SMTP(简单邮件传输协议),SNMP,DNS(域名系统)

###### 传输层

```tcl
       +------+ +-----+ +-----+       +-----+                    
       |Telnet| | FTP | |Voice|  ...  |     |  Application Level 
       +------+ +-----+ +-----+       +-----+                    
             |   |         |             |                       
            +-----+     +-----+       +-----+                    
            | TCP |     | RTP |  ...  |     |  Host Level        
            +-----+     +-----+       +-----+                    
               |           |             |                       
            +-------------------------------+                    
            |    Internet Protocol & ICMP   |  Gateway Level     
            +-------------------------------+                    
                           |                                     
              +---------------------------+                      
              |   Local Network Protocol  |    Network Level     
              +---------------------------+                      

                         Protocol Relationships
```

* 传输层通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能;
* 在传输层有两个性质不同的协议:`TCP`和`UDP`;
* TCP(传输控制协议 全双工),UDP(用户数据包协议),TCP相比UDP多了很多特性,比如流量控制,超时重传,拥塞控制等,这些都是为保证数据包能可靠地传输给对方.
* UDP就相对很简单,简单到只负责发送数据包,不保证数据包是否能抵达对方,但它实时性相对更好,传输效率也高.
* 应用层需要传输的数据可能会非常大,如果直接传输就不好控制,因此当传输层的数据包大小超过MSS(TCP最大报文段长度),就要将数据包分块,这样即使中途有一个分块丢失了或损坏了,只需要重新将发送这个分块,而不用重新发送整个数据包.
* 在TCP协议中,每个分块称为一个TCP段(TCP Segment)

###### 网络层

* 网络层用来处理在网络上流动的数据包,数据是网络传输的最小数据单位.该层规定了通过怎样的路径(传输路线)到达对方计算机,并把数据包传输给对方;
*  ICMP(网际控制报文协议),IGMP(网际组管理协议),IP(网际协议),ARP(地址解析协议),RARP(逆地址解析协议)
*  IPv4协议,IP地址共32位,分成了四段,每段8位.主要提供寻址和路由的功能.
* IP地址分为两个部分:
  *  **网络号**:负责标识该IP地址是属于哪个子网的;
  *  **主机号**:负责标识同一子网下不同主机;
* 需要配合使用**子网掩码**才能算出IP地址的网络号和主机号,在寻址的过程中,先匹配到相同的网络号,才会去找对应的主机.
* **IP协议的寻址作用告诉我们去往下一个目的地该朝哪个方向走,路由则是根据下一个目的地选择路径,寻址更像在导航,路由更像在操作方向盘.**

###### 数据链路层

* 链路层用来处理连接网络的硬件部分,包括控制操作系统,硬件设备驱动,`NIC`(Network Interface Card 网络适配器)以及光纤等物理可见部分.硬件上的范畴均在链路层的作用范围之内.
* 一旦数据需要跨网络传输,就需要有一个设备同时在两个网络当中,这个设备一般是路由器,路由器可以通过路由表计算出下一个要去的IP地址.
* 每一台设备的网卡都会有一个MAC地址,它就是用来唯一标识设备的.路由器计算出了下一个目的地IP地址,在通过ARP协议找到目的地的MAC地址,这样就知道这个IP地址是哪个设备的了.

###### 物理层

* 当数据这边要从设备发送到网络,需要把数据包转换成电信号,让其可以在物理介质中传输,这一层就是物理层.
* 它主要是为数据链层提供二进制传输的服务.

#### 网络硬件

##### 集线器

<img src="https://www.holelin.cn/img/cs-base/http/%E9%9B%86%E7%BA%BF%E5%99%A8.png" alt="img" style="zoom:50%;" />

* 集线器是工作在OSI参考模型**物理层**的转发设备.它从一个端口接收到数据包,然后将数据包传输(中继)到设备的每个端口上.
* 例如,如果一台计算机连接到一个4端口集线器的1号端口上,需要发送数据到连接在2号端口的计算机,那么集线器将会把数据发送给端口2,3,4.连接到3号端口与4号端口上的客户端通过检查以太网帧头字段中目标媒体访问控制地址(MAC),判断出这些数据包并不是给它们的,便丢弃这些数据包.
* 集线器会产生很多不必要的网络流量,并仅在半双工模式下运行(不能再同一时间发送和接收数据).在高密度的实际网络中,集线器最好的替代产品是交换机,它们是支持全双工的设备,可以同时发送和接收数据.

##### 交换机

<img src="https://www.holelin.cn/img/cs-base/http/%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt="img" style="zoom:50%;" />

* 与集线器相同,交换机也是用来转发数据包的,但与集线器不同的是,交换机并不是将数据广播到每一个端口,而是将数据发送到目的计算机所连接的端口上.
* 为了能够直接与一些特定的设备进行通信,交换机必须能够通过MAC地址来唯一标识设备,这意味着它们必须工作在OSI参考模型的**数据链路层**.
* 交换机将每个连接设备的2层地址都存储在一个CAM(Content Addressable Memory:内容寻址寄存器)表中,CAM表充当着一种类似交通警察的角色.
  * 当一个数据包被传输时,交换机读取数据包中的第二层协议头部信息,并使用CAM表作为参考,决定往哪个或者哪些端口发送数据包.交换机仅仅将数据包发送到特定的端口上,从而大大降低了网络流量.

##### 路由器

<img src="https://www.holelin.cn/img/cs-base/http/%E8%B7%AF%E7%94%B1%E5%99%A8.png" alt="img" style="zoom:50%;" />

* 路由器是一种比交换机或集线器具有更高层次功能的先进网络设备.
* 路由器工作在OSI参考模型的第3层,它们负责在两个或多个网络之间转发数据包.路由器在网络间引导数据包流向,这一过程被称为路由.路由器通常使用第3层地址(如IP地址)来唯一标识网络上的设备.

#### 流量分类

##### 广播

* 广播数据包会被发送到一个网段上的所有端口,而不管这些端口连接在集线器还是交换机上.但并非所有的广播流量都是通过相同方式构建的,而是包括第2层广播流量和第3层广播流量的两种主要形式.

  * 在第2层,MAC地址`FF:FF:FF:FF:FF:FF`是保留的广播地址,任何发送到这一地址的流量都将会被广播到整个网段.第3层也有着一些特定的广播地址.

* 在通过多个集线器或交换机连接多种媒介的大型网络中,广播数据包将从一个交换机一直被中继到另一个交换机上,从而传输到网络连接的所有网段上.广播数据包能够到达的区域被称为"广播域",也就是任意计算机可以不用经过路由器即可和其他计算机进行直接传输的网段范围.

  * 广播数据包只能在它特定的广播域中流通.

  ![img](https://www.holelin.cn/img/cs-base/http/%E5%B9%BF%E6%92%AD%E6%95%B0%E6%8D%AE%E5%8C%85.png)

##### 组播

* 组播是一种将单一来源数据包同时传输给多个目标的通信方式.组播的目的是简化这个过程,并使用尽可能少的网络带宽.
* 组播通过避免数据包的大量复制来达到优化效果,而对组播流量的处置方式则高度依赖于不同网络协议的实现细节.
* 实施组播的主要方法是通过一种将数据包接收者加入组播组的编址方案来实现的,这也是IP组播的工作原理.这种编址方案确保数据包不会被传送到未预期的目的地.事实上IP协议将一整段的地址都用于组播,如`224.0.0.0~239.255.255.255`的IP地址可能就是组播流量.

##### 单播

* 单播数据包会从一台计算机知直接传输到另一台计算机.单播机制的具体实现方式取决于使用的协议.

### HTTP

#### HTTP协议概述

* 超文本传输协议(HTTP)是一种**通信协议**,它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器;
* HTTP是一个属于**应用层的面向对象的协议**,由于其简洁,快速的方式,适用于分布式超媒体信息系统,它于1990年提出,经过几年的使用与发展,得到不断地完善和扩展;
* HTTP是一个在计算机世界里面专门在**两点之间传输**文字,图片,音频,视频等**超文本**数据的**约定和规范**

#### HTTP状态码

|      | 具体含义                                                | 常见的状态码                                                 |
| ---- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 1xx  | 提示信息,,表示目前是协议处理的中间状态,还需要后续的操作 |                                                              |
| 2xx  | 成功,报文已经收到并正确处理                             | 200[OK],204[Not Content],206[Partial Conent]                 |
| 3xx  | 重定向,资源位置发生变动,需要客户端重新发送请求          | 301[Moved Permantly],302[Foud],304[Not Modified]             |
| 4xx  | 客户端错误,请求报文有误,服务器无法处理                  | 400[Bad Request],403[Forbidden],404[Not Found]               |
| 5xx  | 服务器错误,服务器在处理请求时内部发生了错误             | 500[Internal Service Error],501[Not Implemented],502[Bad Gateway],503[Service Unavailable] |

* 206是应用于HTTP分块下载或断电续传,表示响应返回的body数据并不是资源的全部,而是其中的一部分,也是服务器处理成功的状态.
* 301表示永久重定向,说明请求的资源已经不存在了,需要改用新的URL再次访问.
* 302表示临时重定向,说明请求的资源还在,但暂时需要用拧一个URK来访问.
* 304不具有跳转的含义,表示资源未修改,重新定向已存在的缓冲文件,也称为缓冲重定向,用于缓存控制

####  HTTP数据传输过程

* **数据封装(Data Encapsulation)**是将**协议数据单元**(PDU)封装在一组协议头和尾中过程.	

![img](https://www.holelin.cn/img/cs-base/http/HTTP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png)

* 发送端发送数据时,数据会从上层传输到下层,且每经过一层都会被打上该层的头部信息.而接收端接收数据时,数据会从下层传输到上层,传输前会把下层的头部信息删除.
* 数据发送处理过程
  * 应用层将数据交给传输层,传输层添加上TCP的控制信息(称为TCP头部),这个数据单元称为段(Segment),加上控制信息的过程称为封装.然后将段交给网络层.
  * 网络层接收到段,再添加上IP头部,这个数据单元称为包(Packet).然后,将包交给数据链路层.
  * 数据链路层接收到包,再添加上MAC头部和尾部,这个数据单元称为帧(Frame).然后,将帧交给物理层.
  * 物理层将接收到的数据转化为比特流,然后在网线中传输.
* 数据接收处理过程
  * 物理层接收到比特流,经过处理后将数据交给数据链路层.
  * 数据链路层将接收到数据转化为数据帧,再除去MAC头部和尾部,这个除去控制信息的过程称为解封装,然后将包交给网络层.
  * 网络层接收到包,再除去IP头部,然后将段交给传输层.
  * 传输层接收到段,再除去TCP头部,然后将数据交给应用层.

### `TCP`协议

#### 为什么需要TCP协议?TCP工作在哪一层?

* IP层是[不可靠],它不保证网络包的交付,不保证网络包的按序交付,也不保证网络中的数据完整性.
  * 如果需要保证网络数据包的可靠性,那么就需要由上层(传输层)的TCP协议来负责.
  * 因为TCP是一个工作在传输层的可靠数据传输的服务,它能确保接收端接收的网络包是无损坏,无间隔,非冗余和按序的.

* TCP是面**向连接,可靠的,基于字节流**的传输层通信协议.
  * 面向连接:一定是一对一才能连接,不能想UDP协议可以一个主机同时向多个主机发送消息.
  * 可靠的:无论网络链路中出现了怎样的链路变化,TCP都可以保证一个报文一定能够到达接收端.
  * 字节流:消息是没有边界的,所以无论消息有多大都可以进行传输,并且消息是有序的,当前一个消息没有收到的时候,即使它先收到了后面的字节,那么也不能扔给应用层去处理,同时对**重复**的报文会自动放弃.

#### `TCP`连接

* 用于保证可靠性和流量控制维护的某些状态信息,这些信息的组合,包括**Socket,序列号和窗口大小**称为连接.
  * Socket: 由IP地址和端口号组成
  * 序列号(Sequence number): 用来解决乱序问题等
  * 窗口大小(Windows sizes): 用来做流量控制

##### `TCP`连接的确定--`TCP`四元组

* 源地址
* 源端口
* 目的地址
* 目的端口
* 源地址和目的地址的字段(32位)是在IP头部中,作用是通过IP协议发送报文给对方主机.
* 源端口和目的端口的字段(16位)是在TCP头部中,作用是告诉TCP协议应该把报文给哪个进程.

##### `TCP`最大连接数

* 服务器通常固定在某个端口上监听,等待客户端的连接请求.

* 客户端IP和端口是可变的,其理论值计算公式如下:

  ```
  最大TCP连接数 = 客户端的IP数 * 客户端的端口数
  ```

  * 对于IPv4,客户端的IP数最多为2的32次方,客户端的端口数最多为2的16次方,也就是服务端单机最大TCP连接数,约为2的48次方.
  * 当然,服务端最大并发TCP连接数远不能达到理论上限.
    * 首先主要是**文件描述符限制**,Socket都是文件,所以首先要通过`ulimit`配置文件描述符的数目;
    * 另一个是**内存限制**,每个TCP连接都要占用一定内存,操作系统的内存是有限的.

##### `TCP`和`UDP`的区别

###### 连接

* TCP是面向连接的传输层协议,传输数据前先要建立连接.
* UDP是不需要连接,即刻传输数据.

###### 服务对象

* TCP是一对一的两点服务,即一条连接只有两个端点.
* UDP支持一对一,一对多,多对多的交互通信.

###### 可靠性

* TCP是可靠交付数据的,数据可以无差错,不丢失,不重复,按需到达.
* UDP是尽最大努力交付,不保证可靠交互数据.

###### 拥塞控制,流量控制

* TCP有拥塞控制和流量控制机制,保证数据传输的安全性.
* UDP则没有,即使网络非常拥堵了,也不会影响UDP的发送速率.

###### 首部开销

* TCP首部长度较长,会有一定的开销,首部在没有使用选项字段时是20个字节,如果使用了选项字段则会变长的.
* UDP首部只有8个字节,并且是固定不变的,开销较小.

###### 传输方式

* TCP是流式传输,没有边界,保证顺序和可靠.
* UDP是一个包一个包的发送,是有边界的,但可能会丢包和乱序.

###### 分片不同

* TCP的数据大小如果大于MSS大小,则会在传输层进行分片,目标主机收到后,也同样在传输层组装TCP数据包,如果中途丢失了一个分片,只需要传输丢失的这个分片.
* UDP的数据大小如果小于MTU大小,则会在IP层进行分片,目标主机收到后,在IP层组装完数据,接着再传给传输层,但是如果中途丢失了一分片,在实现可靠传输的UDP时则就需要重传所有的数据包,这样传输效率非常差,所有通常UDP的报文应该小于MTU.

`TCP`和`UDP`应用场景:

* 由于TCP是面向连接,能保证数据的可靠性交付,因此长用于
  * FTP文件传输
  * HTTP/HTTPS
* 由于UDP面向无连接,它可以随时发送数据,再机上UDP本身的处理既简单又高效,因此常用于:
  * 包总量较少的通信,如DNS,SNMP等
  * 视频,音频等多媒体通信
  * 广播通信

#### TCP协议头

```sh
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            TCP Header Format
```

* 源端口号 Source Port:  16 bits The source port number.

* 目标端口号 Destination Port:  16 bits The destination port number.

* 序列号 Sequence Number:  32 bits 

  > The sequence number of the first data octet in this segment (except when SYN is present). If SYN is present the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.

* 确认应答号 Acknowledgment Number:  32 bits

  > If the ACK control bit is set this field contains the value of the next sequence number the sender of the segment is expecting to receive.  Once a connection is established this is always sent.

* 首部长度 Data Offset:  4 bits

  > The number of 32 bit words in the TCP Header.  This indicates where the data begins.  The TCP header (even one including options) is an integral number of 32 bits long.

* 保留 Reserved:  6 bits

  > Reserved for future use.  Must be zero.

*  控制位 Control Bits:  6 bits (from left to right)

  ```
      URG:  Urgent Pointer field significant
      ACK:  Acknowledgment field significant,该位为1时,[确认应答]的字段变为有效,TCP规定除了最初建立连接时的SYN包之外该位必须设置为1.
      PSH:  Push Function
      RST:  Reset the connection,该位为1时,表示TCP连接中出现异常必须强制断开连接.
      SYN:  Synchronize sequence numbers,该位为1,表示希望建立连接,并在[序列号]的字段进行序列号初始值的设定.
      FIN:  No more data from sender,该位为1时,表示今后不会再有数据发送,希望断开连接.当通信结束希望断开连接时,通信双方的主机之间就可以相互交换FIN位为1的TCP段
  ```

* 窗口大小 Window:  16 bits

  > The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.

* 校验和 Checksum:  16 bits

* 紧急指针 Urgent Pointer  16bits

#### `TCP`连接运行过程中状态

* LISTEN - represents waiting for a connection request from any remote TCP and port.
* SYN-SENT - represents waiting for a matching connection requestafter having sent a connection request.
* SYN-RECEIVED - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.
* ESTABLISHED - represents an open connection, data received can be delivered to the user.  The normal state for the data transfer phase of the connection.
* FIN-WAIT-1 - represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.
* FIN-WAIT-2 - represents waiting for a connection termination request from the remote TCP.
* CLOSE-WAIT - represents waiting for a connection termination request from the local user.
* CLOSING - represents waiting for a connection termination request acknowledgment from the remote TCP.
*  LAST-ACK - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).
* TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.
* CLOSED - represents no connection state at all.

#### `TCP`三次握手

<img src="https://www.holelin.cn/img/cs-base/http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="img" style="zoom:67%;" />

* 使用`TCP`协议进行通信的双方必须先建立连接,然后才能开始传输数据.为了确保连接双方可靠性,在双方建立连接时,`TCP`协议采用了三次握手策略;

###### 握手过程

* 一开始,客户端和服务端都处于`CLOSED`状态.先是服务端主动鉴定某个端口,处于`LISTEN`状态.

* 客户端会随机初始化序号(`client_isn`),将此序号置于TCP首部的序号字段中,同时把`SYN`标志位置为1,表示SYN报文.接着把第一个SYN报文发送给服务端,表示向服务端发起连接,该报文不包含应用层数据,之后客户端处于`SYN-SENT`状态

  <img src="https://www.holelin.cn/img/cs-base/http/TCP%E6%8F%A1%E6%89%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8A%A5%E6%96%87.png" alt="img" style="zoom: 33%;" />

* 服务端收到客户端的`SYN`报文后,首先服务端也随机初始化自己的序号(`server_isn`),将此序号填入TCP首部的序号字段,其次把TCP首部的确认应答号字段填入`client_isn + 1`,接着把`SYN`和`ACK`标志位置为1.最后把该报文发给客户端,该报文也不包含应用层数据,之后服务端处于`SYN-RCVD`状态.

  <img src="https://www.holelin.cn/img/cs-base/http/TCP%E6%8F%A1%E6%89%8B%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8A%A5%E6%96%87.png" alt="img" style="zoom:33%;" />

* 客户端收到服务端报文后,还要向服务端回应最后一个应答报文,首先该应答报文TCP首部`ACK`标志位置为1,其次确认应答号字段填入`server_isn + 1`,最后把报文发送给服务端,这次报文可以携带客户端到服务器的数据,之后客户端处于`ESTABLISHED`状态.

  <img src="https://www.holelin.cn/img/cs-base/http/TCP%E6%8F%A1%E6%89%8B%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8A%A5%E6%96%87.png" alt="img" style="zoom:33%;" />

* 服务器收到客户端的应答报文后,也进入`ESTABLISHED`状态.

* 上述过程中可以发现第三次握手是可以携带数据的,前两次握手是不可用携带数据的.
* 一旦完成三次握手,双方处于`ESTABLISHED`状态,此时连接就已建立完成.客户端和服务端可以相互发送数据了.
* 可以使用`netstat -napt`查看TCP连接状态.

##### 采用三次握手的原因

###### 三次握手才能保证双方具有接收和发送的能力.

###### 三次握手才可以阻止重复历史连接的初始化(主要原因).

  * 为了防止旧的重复连接初始化造成混乱.
  * 三次握手则可以在客户端(发送方)准备发送第三次报文时,客户端因有足够的上下文判断当前连接是否是历史连接:
    * 如果是历史连接(序列号过期或超时),则第三次握手发送的报文是`RST`报文,以此中止历史连接.
    * 如果不是历史连接,则第三次发送的报文是`ACK`,通信双方就会成功建立连接.

###### 三次握手才可以同步双方的初始序列号.

* TCP协议的通信双方,都必须维护一个序列号,序列号时可靠传输的一个关键因素,它的作用:
  * 接收方可以去除重复的数据.
  * 接收方可以根据数据包的序列号按序接收.
  * 可以标识发送出去的数据包中,哪些是已经被对方收到的.
* 序列号在TCP连接中占据着非常重要的作用,所以当客户端发送携带初始化序列号的`SYN`报文的时候,需要服务端回一个`ACK`应答报文,表示客户端的`SYN`报文已被服务端成功接收,那当服务端发送初始序列号给客户端的时候,依然也要得到客户端的应答,这样一来一回,才能确保双方的初始化序列号能被可靠的同步.

###### 三次握手才可以避免资源浪费.

###### 总结

* 三次握手能防止历史连接的建立,能减少双方不必要的资源开销,能帮助双方同步初始化序列号.序列号能保证数据包不重复,不丢弃和按序传输.
* 两次握手:无法防止历史连接的建立,会造成双方资源的浪费,也无法可靠的同步双方序列号.
* 四次握手:三次握手就已经理论上最少可靠连接建立,所以不需要使用更多的通信次数.

##### MTU和MSS

![img](https://www.holelin.cn/img/cs-base/http/MTU%E5%92%8CMSS.png)

* MTU:一个网络包的最大长度,以太网中一般为1500字节.
  * 当IP层数据超过MTU大小要发送,则IP层就要进行分片,把数据分片成
* MSS:除去IP和TCP头部之后,一个网络包所能容纳的TCP数据的最大长度.
  * 当TCP层发现数据超过MSS时,则就先会进行分片
  * 当一个TCP分片丢失后,进行重发时也是以MSS为单位,而不用重传所有的分片,大大增加了重传的效率.

#### `SYN`攻击

* TCP连接建立是需要三次握手,假设攻击者短时间伪造不同IP地址的`SYN`报文,服务端每接收到一个`SYN`报文,就进入`SYN_RCVD`状态,但服务端发送出去的`ACK + SYN`报文,无法得到未知IP主机的`ACK`应答,久而久之就会占满服务端的`SYN`接收队列(未连接队列),使得服务器不能为正常用户服务.

##### 避免SYN攻击方式

* 修改Linux内核参数,控制队列大小和当队列满时应做什么处理.

  ```sh
  # 当网卡接收数据包的速度大于内核处理的速度时,会有一个队列保存这些数据包.控制该队列的最大值
  net.core.netdev_max_backlog
  # SYN_REVD状态连接的最大个数
  net.ipv4.tcp_max_syn_backlog
  # 超出处理能力时,对新的SYN直接回复RST,丢弃连接
  net.ipv4.tcp_abort_onoverflow
  ```

* Linux内核的SYN(未完成连接建立)队列与Accpet(已完成连接建立)队列如何工作的?

  * 正常流程

    * 当服务端收到客户端的SYN报文时,会将其加入到内核的SYN队列;
    * 接着发送SYN+ACK给客户端,等待客户端回应ACK报文;
    * 服务端接收到ACK报文后,从SYN队列移除放入到Accept队列;
    * 应用通过调用accept() socket接口,从Accpet队列取出连接.

  * 应用程序过慢

    * 如果应用程序过慢时,就会导致Accpet队列被占满.

  * 受到SYN攻击

    * 如果不断受到SYN攻击,就会导致SYN队列被占满

      ```sh
      # tcp_syncookies的方式可以应对SYN攻击的方法
      net.ipv4.tcp_syncookies = 1
      ```

  * `SYN`队列占满,启动`cookie`

    * 当`SYN`队列满之后,后续服务器收到SYN包,不进入`SYN`队列
    * 计算出一个`cookie`值,再以`SYN + ACK`中的序列号返回客户端
    * 服务端收到客户端的应答报文时,服务器会检查这个`ACK`包的合法性.如果合法,直接放入到Accpet队列.
    * 最后应用通过accpet()socket接口,从Accpet队列取出连接

#### `TCP`四次挥手

![img](https://www.holelin.cn/img/cs-base/http/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

* 主动关闭连接的一方，调用close()；协议层发送FIN包
*  被动关闭的一方收到FIN包后，协议层回复ACK；然后被动关闭的一方，进入CLOSE_WAIT状态，主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作
*  被动关闭的一方在完成所有数据发送后，调用close()操作；此时，协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入LAST_ACK状态；
*  主动关闭的一方收到FIN包，协议层回复ACK；此时，主动关闭连接的一方，进入TIME_WAIT状态；而被动关闭的一方，进入CLOSED状态
*  等待2MSL时间，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态

##### 结论

* 主动关闭连接的一方 - 也就是主动调用socket的close操作的一方，最终会进入TIME_WAIT状态
*  被动关闭连接的一方，有一个中间状态，即CLOSE_WAIT，因为协议层在等待上层的应用程序，主动调用close操作后才主动关闭这条连接
*  TIME_WAIT会默认等待2MSL时间后，才最终进入CLOSED状态；
*  在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的！

#### `TCP`连接状态转换图

```
                              +---------+ ---------\      active OPEN  
                              |  CLOSED |            \    -----------  
                              +---------+<---------\   \   create TCB  
                                |     ^              \   \  snd SYN    
                   passive OPEN |     |   CLOSE        \   \           
                   ------------ |     | ----------       \   \         
                    create TCB  |     | delete TCB         \   \       
                                V     |                      \   \     
                              +---------+            CLOSE    |    \   
                              |  LISTEN |          ---------- |     |  
                              +---------+          delete TCB |     |  
                   rcv SYN      |     |     SEND              |     |  
                  -----------   |     |    -------            |     V  
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |<-----------------           ------------------>|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |<-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------                  
   |                  x         |     |     snd ACK                    
   |                            V     V                                
   |  CLOSE                   +---------+                              
   | -------                  |  ESTAB  |                              
   | snd FIN                  +---------+                              
   |                   CLOSE    |     |    rcv FIN                     
   V                  -------   |     |    -------                     
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |<-----------------           ------------------>|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |  
   | --------------   snd ACK   |                           ------- |  
   V        x                   V                           snd FIN V  
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |  
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |  
   |  -------              x       V    ------------        x       V  
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------>|TIME WAIT|------------------>| CLOSED  |
                              +---------+                   +---------+

                      TCP Connection State Diagram
```

![img](https://www.holelin.cn/img/cs-base/http/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)

##### `TIME_WAIT`状态

* `TIME_WAIT`状态也被称为`2MSL`等待状态.在该状态将会等待两倍于最大段生存期(Maximum Segment Lifetime,MSL)的时间

  * `TIME_WAIT`等待2倍的MSL的原因为:网络中可能存在来自发送的数据包,当这些发送方的数据包被接收方处理后又会向对方发送响应,所以一来一回响应等待2倍的时间
  * `2MSL`的时间是从客户端接收到`FIN`后发送`ACK`开始计时的.如果在`TIME_WAIT`时间内,因为客户端的`ACK`没有传输到服务端,客户端又接收到了服务端重发的`FIN`报文,那么`2MSL`时间将重新计时.

* 在Linux系统中,`net.ipv4.tcp_fin_timeout`的数值记录了`2MSL`状态需要等待的超时时间(以秒为单位)

  ```properties
  net.ipv4.tcp_fin_timeout = 2
  # 为1表示允许将TIME-WAIT的句柄重新用于新的TCP连接
  net.ipv4.tcp_tw_reuse = 1
  # 为1表示开启TCP连接中TIME-WAIT的快速回收，NAT环境可能导致DROP掉SYN包（回复RST）
  net.ipv4.tcp_tw_recycle = 1
  # 为1时SYN Cookies，当SYN等待队列溢出时启用cookies来处理，可防范少量SYN攻击
  net.ipv4.tcp_syncookies = 1
  # 当keepalive起用的时候，TCP发送keepalive消息的频度，单位为秒，缺省是7200秒（即2小时）
  net.ipv4.tcp_keepalive_time = 600
  #  端口最大backlog内核限制，防止占用过大内核内存
  net.ipv4.ip_local_port_range = 4000 65000
  net.ipv4.tcp_max_syn_backlog = 16384
  # 保持TIME_WAIT套接字的最大个数，超过这个数字TIME_WAIT套接字将立刻被清除并打印警告信息
  net.ipv4.tcp_max_tw_buckets = 36000
  net.ipv4.route.gc_timeout = 100
  #  对一个新建连接，内核要发送多少个SYN连接请求才决定放弃，不应该大于255
  net.ipv4.tcp_syn_retries = 1
  net.ipv4.tcp_synack_retries = 1
  net.core.somaxconn = 16384
  net.core.netdev_max_backlog = 16384
  # 不属于任何进程（已经从进程上下文中删除）的sockets最大个数，超过这个值会被立即RESET，并同时显示警告信息
  net.ipv4.tcp_max_orphans = 16384
  ```

* 假设已设定MSL的数值,按照规则:当TCP执行一个主动关闭并发送最终的ACK时,连接必须处于`TIME_WAIT`状态并持续两倍于最大生存周期(`2MSL`)的时间.这样能够让TCP重新发送最终的ACK以避免出现丢失的情况.重新发送最终的ACK并不是因为重传了ACK(它们并不消耗序列号,也不会被TCP重传),而是因为通信另一方重传了它的FIN(它消耗一个序列号).事实上,TCP总是重传FIN,直到它收到一个最终的ACK.

* 影响`2MSL`等待状态的因素是当TCP处于等待状态时,通信双方将该连接(客户端IP地址,客户端端口号,服务器IP地址,服务器端口号)(四元组)定义为不可重新使用.只有当`2MSL`等待结束时,或一条新连接使用的初始化序列号超过了连接之前的实例使用的最高序列号时,或者允许使用时间戳选项来区分之前连接实例的报文段以避免混淆时,这条连接才能被再次使用.不幸的是,一些实现施加了更加严格的约束,**在这些系统中,如果一个端口号被处于`2MSL`等待状态的任何通信端所用,那么该端口号将不能被再次使用.**

* 使用`ss -tan state time-wait | wc -l ` 查看`TIME_WAIT`的连接数量

##### `TIME_WAIT`过多的危害

* 第一是内存资源占用
* 第二是对端口资源的占用,一个TCP连接至少消耗一个本地端口
  * 一般可以开启的端口为`32768~61000`,也可以通过`net.ipv4.ip_local_port_range`
* 如果发起连接一方的`TIMET_WAIT`状态过多,占满了所有端口资源,则会导致无法创建新连接.
  * 客户端手端口资源限制:
    * 客户端`TIME_WAIT`过多,就会导致端口资源被占用,因为端口就`65536`个,被占满就会导致无法创建新的连接.
  * 服务端受系统资源限制:
    * 由于一个四元组标志TCP连接,理论上服务端可以建立很多连接,服务端确实只监听一个端口,但是会把连接扔给线程,所以理论上监听的端口可以继续监听.但是线程池处理不了那么多一直不断的连接了.所以当服务端出现大量`TIME_WAIT`时,系统资源被占满时,会导致不过来新的连接.

##### 优化`TIME_WAIT`

* 打开`net.ipv4.tcp_tw_reuse`和`net.ipv4_tcp_timestamps`选项;
* `net.ipv4.tcp_max_tw_buckets`
* 程序中使用`SO_LINGER`,应用强制使用`RST`关闭

#### `UDP`

##### `UDP`头部格式

```
  							  0      7 8     15 16    23 24    31  
                 +--------+--------+--------+--------+ 
                 |     Source      |   Destination   | 
                 |      Port       |      Port       | 
                 +--------+--------+--------+--------+ 
                 |                 |                 | 
                 |     Length      |    Checksum     | 
                 +--------+--------+--------+--------+ 
                 |                                     
                 |          data octets ...            
                 +---------------- ...                 

                      User Datagram Header Format
```

* 源端口号(16位)和目标端口(16位): 主要是告诉UDP协议应该把报文发给哪个进程.
* 包长度: 该字段保存了UDP首部的长度跟数据的长度之和.
* 校验和: 校验和是为了提供可靠的UDP首部和数据而设计.

#### ARP基础知识

* ARP(Address Resolution Protocol)地址解析协议是根据IP地址获取物理地址的一个TCP/IP协议.
* 由于OSI模型把网络分为七层,IP地址在OSI模型的第三层,MAC地址在第二层,彼此不能直接通信.在通过以太网发送IP数据包时,需要先封装第三层(32位IP地址),第二层(48为MAC地址)的报头.但由于发送数据包时只知道目标IP地址,不知道其MAC地址,而不能跨越第二层,所以需要使用地址解析协议.

* 使用地址解析后,计算机可根据网络层IP数据包包头中的IP地址信息对应目标硬件地址(MAC地址)信息,以保证通信的顺利进行.ARP的基本功能就是负责将一个已知的IP地址解析成MAC地址,以便主机能正常进行通信.

##### ARP工作流程

* ARP工作过程分为两个阶段:一个ARP请求过程,一个是ARP响应过程.
* 两台主机(PC1:192.168.1.1 PC2:192.168.1.2)详细通信过程:
  * 当主机PC1想发送数据给主机PC2时,首先在自己的本地ARP缓存表中检查主机PC2配置的MAC地址.
  * 如果主机PC1在缓存中没有找到相应的条目,它将询问主机PC2的MAC地址,从而将ARP请求帧广播到本地网络上的所有主机.该帧中包括员主机PC1的IP地址和MAC地址.本地网络上的每台主机都接收到了ARP请求并且检查是否与自己的IP地址匹配.如果主机发现请求的IP地址与自己的IP地址不匹配,它将会丢弃ARP请求.
  * 主机PC2确定ARP请求中的IP地址与自己的IP地址匹配,将主机PC1的地址和MAC地址添加到本地缓存表.
  * 主机PC2将包含其MAC地址的ARP回复消息直接发送回主机PC1(这个数据帧是单播).
  * 当主机PC1收到从主机PC2发来的ARP回复消息时,会将主机PC2的IP和MAC地址添加到自己的ARP缓存表.本机缓存是有生存期的,默认ARP缓存表的有效期是120s.当超过有效期后,将重复上面的过程.主机PC2的MAC地址一旦确定,主机PC1将能向主机PC2发送IP通信了.

##### ARP缓存表维护工具-arp命令

* 该命令用于查询本机ARP缓存中的IP地址和MAC地址的对应关系,添加或删除静态对应关系.

  ```sh
  ╭─ ~                                                            11:34:59 
  ╰ arp
  usage: arp [-n] [-i interface] hostname
         arp [-n] [-i interface] [-l] -a
         arp -d hostname [pub] [ifscope interface]
         arp -d [-i interface] -a
         arp -s hostname ether_addr [temp] [reject] [blackhole] [pub [only]] [ifscope interface]
         arp -S hostname ether_addr [temp] [reject] [blackhole] [pub [only]] [ifscope interface]
         arp -f filename
  * -s inet_addr eth_addr [if_addr]: 向ARP缓存表中添加可将IP地址inet_addr解析成物理地址eth_addr的静态条目.要向指定接口的表添加ARP缓存条目,使用if_addr参数,此处的if_addr代表指派给该接口的IP地址;
  * -d inet_addr if_addr: 删除指定的IP条目,此处的inet_addr代表IP地址.对于指定的接口,要删除表中的某项,使用if_addr,此处的if_addr代表指派给该接口的IP地址.要删除所有条目,使用星号(*)通配符代表inet_addr;
  * -a inet_addr[-N if_addr]: 显示所有接口的当前ARP缓存表.要显示特定IP地址的ARP缓存项,使用带有inet_addr参数的arp -a,此处的inet_addr代表IP地址.如果未指定inet_addr,则使用第一个适用的接口.要显示特定接口的ARP缓存表,将-N if_addr与-a参数一起使用,此处的if_addr代表指派给该接口的IP地址.-N参数区分大小写.
  * -v 查看帮助信息
  ```

#### ARP报文格式

<img src="https://www.holelin.cn/img/cs-base/http/ARP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="img" style="zoom:67%;" />

* 第一个字段是广播类型的MAC地址:`0XFF-FF-FF-FF-FF-FF`,其目的是网络上的所有主机.
* 第二个字段是源MAC地址,即请求地址解析的主机MAC地址.
* 第三个字段是协议类型
* 硬件类型:表明ARP协议实现在哪种类型的网络上.
* 协议类型:表示解析协议(上层协议).这里一般是0800即IP.
* 硬件地址类型长度:MAC地址长度,此处为6个字节.
* 协议地址长度:IP地址长度,此处为4个字节.
* 操作类型:表示ARP协议数据包类型
  * 1:表示ARP协议请求数据包
  * 2表示ARP协议应答数据包
* 源MAC地址:发送端MAC地址
* 源IP地址:表示发送端协议地址(IP地址)
* 目标MAC地址:目标MAC地址
* 目标IP地址:表示目标段协议地址(IP地址)

#### IP数据报首部格式

![img](https://www.holelin.cn/img/cs-base/http/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg)

* 版本号: 指IP协议所使用的版本.通信双方使用的IP协议版本必须一致.目前广泛使用的IP协议版本号为4,即IPv4.
* 首部长度:IP的首部长度,可表示的最大十进制数值是15.注意,该字段所表示的单位是32位字长(4字节).因此,当IP首部长度为1111(即十进制的15)时,首部长度就达到60字节.当IP分组的首部长度不是4字节的整数倍时,必须利用最后的填充字段加以填充.
* 服务类型:优先级标志位和服务类型标志位.被路由器用来进行流量的优先排序.
* 总长度:指IP首部和数据报中数据之后的长度,单位为字节.总长度字段为16位,因此数据报的最大长度为216-1=65535字节.
* 标识符:一个唯一的标识数字,用来识别一个数据报或者被分片数据包的次序.
* 标记:用来标记一个数据报是否是一组分片数据报的一部分.标志字段中的最低位记为MF(More Fragment).MF=1即表示后面"还有分片"的数据报.MF=0表示这个已是若干数据包分片中最后一个.标志字段中间的一位记为DF(Don't Fragment),意思是"不能分片".只有当DF=0时,才允许分片.
* 分片偏移:一个数据报是一个分片,这个域中的值就会被用来将数据报以正确的顺序重新组装.
* 存活时间:用来定义数据报的生成周期,以经过路由器的条数/秒数进行描述.
* 协议:用来识别在数据包序列中上层协议数据报的类型.
* 首部校验和:一个错误检测机制,用来确认IP首部的内容有没有被损坏或者被篡改.
* 源IP地址:发出数据报的主机的IP地址.
* 目的IP地址:数据报目的地IP地址.
* 选项:保留作额外的IP选项,它包含着源站选路和时间戳的一些选项.
* 数据:使用IP传递的实际参数.

##### `TTL`

* 存活时间(TTL)值定义了在该数据报被丢弃之前,所能经历的时间,或者能经过的最大路由数目.TTL在数据报被创建时就会被定义,而且通常在每次被发往一个路由器的时候减1.

##### IP分片

* 数据报分片是将一个数据流分为更小的片段,是IP用于解决跨域不同类型网络时可靠的一个特性.一个数据报的分片主要是基于第二层数据链路层所使用的最大传输单元(Maximum Transmission Unit MTU)的大小,以及使用这些二层协议的设备情况.在多数情况下,第二层所使用的最大数据报大小是1500字节(不包括14字节的以太网头本身).
* 当一个设备这边传输一个IP数据报时,它将会比较这个数据报的大小,以及将要把这个数据报传送出去的网络接口MTU,用于决定是否需要将这个数据报分片.如果数据报的大小大于MTU,那么这个数据报将会被分片.将一个数据报分片包括下列几个步骤:
  * 设备将数据分为若干个可成功进行传输的数据报.
  * 每个IP首部的总长度域会被设置为每个分片的片段长度.
  * 更多分片标志将会在数据流的所有数据报中设置为1,除了最后一个数据报.
  * IP头中分片部分的分片偏移将会被设置.
  * 数据报被发送出去.

##### 
